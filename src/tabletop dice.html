<!DOCTYPE HTML>
<html>
<head>
<title>Tabletop Dice</title>
<meta charset="ASCII" />
<style>
p.function
{
   font-family: monospace;
   margin-bottom: 0;
}
p.description
{
   font-family: monospace;
   margin-left: 20px;
   margin-top: 0;
}
p.basic
{
   margin-top: 0;
   margin-bottom: 0;
}
</style>
<script type="text/javaScript">var includePath = 'library/';</script>
<script type="text/javaScript" src="library/include.js"></script>
<script>
/**
Called by the Execute button. It simply calls eval() on the inputCode's text and writes to results if there was an error.
*/
function main()
{
   document.getElementById('results').value = '';
   document.getElementById('graphResults').innerHTML = '';
   var didThrow = true;
   try
   {
      eval(document.getElementById('inputCode').value);
      didThrow = false;
   }
   finally
   {
      if (didThrow)
      {
         if('' !== document.getElementById('results').value) writeln();
         writeln('An error has occurred check the console for details.');
      }
   }
   //writeln("\nEnd of program");
}
/**
@param {!string} message to append to the results text area.
*/
function write(message){document.getElementById('results').value += message;}
/**
@param {!string} message to append to the results text area followed by an new line.
*/
function writeln(message)
{
   if(0 === arguments.length) message = '';
   write(message + '\n');
}
/**
Hides or shows the bottom section of Function Documentation.
*/
function toggleDoc()
{
    var docStyle = document.getElementById('functionDoc').style;
    if('none' === docStyle.display) docStyle.display = 'inline';
    else docStyle.display = 'none';
}
</script>
<base target="_blank" />
</head>
<body>
<br />
<label for="inputCode">Code:</label><br />
<textarea id="inputCode" rows="7" cols="50">var myDiceString="2d6";
rollDice(myDiceString);
Draw.diceBellCurve(new DicePool(myDiceString));
</textarea><br />
<input type="button" onclick="main();" value="Execute" /><br />
<br /><label for="results">Output:</label><br />
<textarea id="results" rows="7" cols="50"></textarea><br />
<div id="graphResults"></div>
<!--
various notes:
rewrite everything
-named dice should not be instanceof die. call the new object Spinner: to String/JSON, getSides, roll etc
-NumericSpinner also. which has all die functions (some may do nothing)
-also consider SimpleDie: Math.ceil(Math.random()*sideCount); 2 is either 1 or 2
-methods for string parsing. die only takes string or json
-dicepool only takes string, array of json, or array of die
-make dice and dicepool's toString return the code needed to create them: 'new DicePool("2d6")' toJSON only return "2d6"
-make sure to doc everything: including include.js
-make sure it is all tested
-currently explosions must be before reroll (put in functions)
consumers:
-warhammer
-L5R
-eval
-a form for dice, add to pool button, roll pool, and stats pool
look into pre-commit jsDoc
look into the syntax highlighter that code school uses (able to type into)
gh-pages
finish stack exchange
then look into new functionality
-custom die takes a callback function which is sent the value on roll
-maybe above can simplify min/max, reroll, explosions, etc
-make a numbered Spinner which can be used for stats etc
-deck object? not what this was made for...
-consider allowing fudge dice to be f3 or 3f without requiring dz

stats note: http://mathforum.org/library/drmath/view/52207.html
this approach will work fast but will not work for named dice and drop/keep
could Look up combinatorics and generating functions for drop/keep

this compared to others:
{
https://wiki.roll20.net/Dice_Reference
the syntax for count successes is different (due to using shorthand instead of a function)
allows for multiple reroll criteria
Grouping Rolls. which will be very difficult: {4d6+3d8}kh1 means keep highest 1 of that pool but can also {4d6+3d8, {4d2+2d4}}kh1
    https://wiki.roll20.net/Dice_Reference#Grouped_Rolls

http://en.wikipedia.org/wiki/Dice_notation
using x to mean * there's also (division sign) for / but there's no keyboard for that so it's harder to detect
names Penetrating exceptions
    example function
one system that has 1-5 explode on d%
    due to rare make example function

http://anydice.com/
not sure whether local or server. it's fast and has js but that's just for the tabs and forms etc
is a new language. limitation of max total depth of functions (not just recursion)
has a few functions: explode (all explodes are regular) and sort
does not have any javascript libraries (obviously) but does have abs and 3 things
"2d10!!r1" is very difficult. nothing is impossible due to programming
ditto for "2d10!p"
min/max doesn't exist
learning curve: if you've used roll20 (standard dice notation) then it won't help you at all
has some interesting stuff like d3 > d2 but none of them I would call useful
drop/keep exists and can add pools and perform basic math
you must make custom dice for rerolls but {2..10} is simple
fudge dice is {-1,0,1}

http://topps.diku.dk/torbenm/troll.msp
server-side computations (painful as it refreshes entire page)
is a new language
their min/max functions are keep lowest/highest
but there is no actual min/max
(their drop/keep is useless as it drops specific values instead of lowest highest)
there is no real drop/keep
they have regular exploding (although not user friendly)
they do not have p or compound exploding
you can add dice but not dice pools ie: "d6+d6+d8" but not "2d6+d8"
basic math is the same way (counts as singleton and pools are not)
there are no fudge dice
has plenty of predefined functions and allows users to make them
they have reroll (although not user friendly)

only a sim: http://rpggeek.com/filepage/64586/l5r-roller

http://rumkin.com/reference/dnd/diestats.php
has xk1 averages from 1-10
I don't understand his c program
}
-->
<br /><br /><a style="text-decoration: underline; font-weight: bold;">Basic Description:</a><br />
<p class="basic">The dice notation used most closely resembles <a href="https://wiki.roll20.net/Dice_Reference">Roll20.net</a> which
uses syntax well known as demonstrated by <a href="http://en.wikipedia.org/wiki/Dice_notation">Wikipedia</a></p>
<p class="basic">The Code section is sent to eval() that is to say it is javascript with predefined functions (see their
documentation below).</p>
<p class="basic">All numbers must be whole numbers, although named dice can have sides named as any value including decimal
numbers (named dice are for advanced users).</p>
<p class="basic">The string variable named myDiceString (as default above) is sent to both the rollDice and Draw.diceBellCurve
functions.</p>
<p class="basic">The rollDice function will generate random numbers and output the result. The Draw.diceBellCurve function draws
statistics of for the dice specified.</p>
<p class="basic">For the basic user change the 2d6 to whatever dice is desired (the quotes must remain).</p>
<p class="basic">Continue reading this section for information on how to specify the dice desired.</p>
<p class="basic">The dice options and dice pools may be in any order, however shorthand (if any) must follow the dice then the long
hand (if any).</p>
<p class="basic">When the description shows a format: # is a number, | is "or" and [] are optional the () are for grouping. Do not
include any of these symbols when using the program.</p>
<p class="basic">An advanced user should also read the function documentation section which explains every function available. An
advanced user must understand the <a href='http://www.w3schools.com/js/'>basics of javascript</a>.</p>
<p class="basic">The function rollDice expects the dice string to be in the form of XdY where X is the number of dice, d is the dice
type, and Y is the number of sides each die has.</p>
<p class="basic">Each die in the pool is added together. A leading negative ('-') may be used for each die to be negative.</p>
<p class="basic">The string given to rollDice is not case sensitive but everything else is case sensitive. The string given to rollDice
converts all whitespace into spaces.</p>
<p class="basic">Some replacements are done before any other processing: XkY translates into Xd10!! keep highest Y. Keep reading for
an explanation.</p>
<p class="basic">If the number of sides starts with a % (Xd%) it is replaced with 100 (Xd100). then all remaining % are replaced with
'00'. For example 2d2% becomes 2d200 and 1d%% becomes 1d10000</p>
<p class="basic">The dice type can be either 'd' or 'z'. In XdY the sides of d (die) are numbered from 1 to Y and z (zero) are from 0
to Y-1.</p>
<p class="basic">Fudge dice (aka Fate dice) are supported. To use them say XdF (or XzF). Fudge die have 3 sides which are labeled -1,
0, and +1.</p>
<br />
<p class="basic">You can ignore certain values by putting "drop lowest 2" where the 2 lowest values will be removed or "keep the highest
3" where all but the 3 highest values will be dropped.</p>
<p class="basic">If no number is given for drop/keep then the number 1 is used. You can also use the words "remove" or "ignore" to do
the same thing as "drop".</p>
<p class="basic">Here's the full format of drop/keep: (drop[ping]|remov(e|ing)|ignor(e|ing)|keep[ping]) [the ](low|high)est[ #].</p>
<p class="basic">The number of values to drop (x) must be: 0 &lt;= x &lt;= number of dice. If the number of dice to keep is more than
the number of dice then all of them are kept. Number of dice and number of side must be greater than 0.</p>
<br />
<p class="basic">Exploding, compound exploding, and penetrating exploding dice are supported.</p>
<p class="basic">Explosions of any kind have the format: [penetrating|penetrate|compound[ing]] (explosion[s]|exploding|explode) [di[c]e].</p>
<p class="basic">Exploding dice means that whenever a die rolls the highest possible value, another die is rolled of the same number of
sides. Any number of dice can explode any number of times including the new die added.</p>
<p class="basic">Using any kind of exploding dice means that there is no maximum sum, although the higher numbers being less likely.</p>
<p class="basic">Penetrating exploding dice means that whenever a die explodes the new die rolled has 1 subtracted from that roll.</p>
<p class="basic">Each die added from a penetrating explosion may also explode (whether or not is rolled max value is determined before
1 is subtracted). Each new die only has 1 subtracted from it (it does not accumulate).</p>
<p class="basic">For example: "2d10 penetrate explode" rolls 6 and 10, the second die explodes so that another (1d10-1) is rolled which
gets a (10-1=9) then a (3-1=2). The total is 6+10+9+2=27.</p>
<p class="basic">Compound exploding dice means that whenever a die explodes the new die rolled is added directly to the die that exploded
as though it was a single die. Dice can compound explode any number of times.</p>
<p class="basic">For example: "2d6 explode drop highest" rolls 6 and 1, the first die exploded so that another 1d6 is rolled which gets
a 6 then a 2. Every die is 6+1+6+2 so that one of the 6s is dropped due to being the highest.<br />So that the result is 6+1+2=9.</p>
<p class="basic">However if it was compound: "2d6 compound explode drop highest" rolls (6+6+2) and 1 which is 14 and 1. A total of 1
after dropping the highest (14 is the highest die).</p>
<br />
<p class="basic">You may establish a minimum or maximum value for a set of dice like: XdY [with] [a] (min|max)[imum] [of] #. This will
only change the total of those dice.</p>
<p class="basic">Minimum and maximum can have a negative value in which case note that: -&infin; &lt; min &lt;= sum and -&infin; &lt;
sum &lt;= max. Which means that '-2d6 min -2' will always be -2 since -2d6 can't have a sum higher than -2.</p>
<br />
<p class="basic">Constants may be added to either the sum or individual dice. If the constant is before any dice then it is added to the
sum (it may have a leading -).</p>
<p class="basic">Any other constants will be added to the dice set before it in which case the number is added to each side's value.</p>
<p class="basic">For example: "2+2d6" rolls 5 and 1 for a total of 2+5+1=8. But "2d6+2" rolls (5+2=7) and (1+2=3) for a total of 7+3=10.</p>
<p class="basic">Currently the only way to connect dice and constants to dice and constants is with either + or -. You can't have a
leading + or a adding a negative.</p>
<br />
<p class="basic">You may have certain die values be rerolled. A range of values or a specific value may be given (see format).</p>
<p class="basic">Rerolling has this format: reroll [di[c]e [that are]] (greater|less) than [or equal [to]] #. Or this one: reroll [di[c]e
[that are]] [not] equal [to] #.</p>
<p class="basic">Whenever a die lands on a value it is compared to the reroll criteria and that die is rolled again and again until it
is a value that is allowed.</p>
<br />
<p class="basic">Sorting of the dice values may be done. This has no impact on the functionality only on the output.</p>
<p class="basic">Sorting has this format: sort [[the] dice] [in] [ascending|descending] [order].</p>
<p class="basic">All values are broken up into numbers and others with the numbers coming before everything else.</p>
<p class="basic">The sort is either ascending or descending with the numbers being sorted numerically and the others alphabetically.
Ascending is default.</p>
<br />
<p class="basic">All dice options have shorthand notation. An exception is that for the dice themselves there is no longhand for number
of sides and number of dice.</p>
<p class="basic">All plus and minus must also be symbolic (such as '+') instead of using words. Constants must remain the same. There is
no shorthand for minimum and maximum.</p>
<p class="basic">All shorthand follows the dice without a space such as: "2d6!dL". The shorthand may be in any order following the dice.</p>
<p class="basic">Drop/Keep shorthand format is: XdY(d|k)[h|L][#]. where 'd' is for 'drop' and 'k' for 'keep'. 'L' for
'Lowest' or 'h' for highest.</p>
<p class="basic">Exploding shorthand is: XdY! for regular exploding dice, XdY!! for compound exploding, and XdY!p for
penetrating exploding.</p>
<p class="basic">Rerolling shorthand format is: XdYr[?]#. Replace the optional '?' with any form of comparison operator such as '&lt;='
or '!='. If 'r=#' or 'r#' is given it will be replaced with 'r==#'.</p>
<p class="basic">Sorting shorthand format is: XdYs[a|d]. 'a' is ascending (which is default if 's' is alone) and 'd' is descending.</p>
<br />
<p class="basic">Example String: "3d2 +3d4! drop the lowest 2"</p>
<p class="basic">Example String: "5 + 5z5r5!! + 5"</p>
<p class="basic">Example String: "4k3sa"</p>
<p class="basic">Example String: "4dF+2d3!!"</p>
<br />
<p class="basic">The Twister spinner choices are either red, green, yellow, or blue on either left or right, hand or foot (16 options).</p>
<p class="basic">The 20 possible Magic 8-Ball responses are:</p>
<pre style="color: green;">
As I see it, yes
It is certain
It is decidedly so
Most likely
Outlook good
Signs point to yes
Without a doubt
Yes
Yes - definitely
You may rely on it
</pre>
<pre>
Reply hazy, try again
Ask again later
Better not tell you now
Cannot predict now
Concentrate and ask again
</pre>
<pre style="color: red;">
Don't count on it
My reply is no
My sources say no
Outlook not so good
Very doubtful
</pre>
<br /><br />
<a href="javascript:toggleDoc();">Toggle Function Documentation</a><br />
<div id="functionDoc" style="display: none;"><h1>Function Documentation</h1>
<a>If you are reading this you have no excuse not to have a modern browser.</a><br />
<h3>Predefined function list</h3>
<pre>
isBotch(valueArray, botchValue)
    checks to see if every number in valueArray matches the botchValue
    botchValue is 1 by default (in this way it can't be undefined)
    valueArray can be either a number or an array of values (numbers or otherwise)
    returns true if every value in the array matches (using ==) the botchValue
    returns false if any is not the botchValue
argumentsToArray(argumentsGiven, fromIndex)
    converts an argument object into an array starting from the fromIndex and returns the array
    if the returned array would contain only a single element which is an array instead that first element is returned
IronClawEvenRolls(numberArray1, numberArray2)
    a utility used for the Iron Claw example functions
    first the 2 arrays are sorted descending
    then every 1 is removed from each array
    then the shorter array has 1s added to it until it is the same length
    the arrays are changed but nothing is returned
combineRegex(regex1, regex2)
    takes any combination of 2 strings or regex objects, concatenates them, and returns the new regex as a regex object
everyDieValueWeighted(myDie)
    this is a utility used for drawing bell curves for dice. myDie is a die object
    the return value is a 2D array in the form of [value, freq or chance]
    explosions are included. the last values of the explosion will have chance rounded to 5 decimal places
    the result is returned and the parameters are not changed
explodeSplit(rollData, diceArray)
    this is a utility used for drawing bell curves for dice. diceArray is a 1D array of die objects
    rollData must be a 2D array in the form of [value, chance] with the value as though it was compound
    this function splits the die value that's exploded into its smaller parts
    this function assumes that the minimum value is more than 0. Do not call this function if this is not true as the results will not be correct
    the result is returned (in the same form as rollData) and the parameters are not changed
generate_Binomials(trials, probability)
    using the number of trials and probability this function loops for each possible
    number of successes and returns an array of each chance (probability) with the array index representing the number of successes
    if you want the chance of getting exactly a number then use that array index otherwise you will need to sum up these mutually exclusive events
Combination(numberDesired, trials)
    used for generate_Binomials but is general enough that someone else might want to use it
    the formula is n!/(k!*(n-k)!) where n=trials and k=numberDesired
    the result is returned
cartesianProduct(array1Given, array2Given)
    returns a 2D array which has every possible combination of the elements of the 2 arrays given
    the result has a minimum of 2D. It will have 2 dimensions only if each array given is 1D
    see the example following nextCartesianProduct
nextCartesianProduct(array1Given, array2Given)
    this functions just like cartesianProduct except that array1Given is the result of either Cartesian product function
    this takes the each element of array1Given as an array and appends to it every possible element of array2Given
    the inputs array1Given and array2Given are not changed. the returned array is of the same format as cartesianProduct
    if sending 2 arrays to cartesianProduct would result in this: [[[a, 1], red], [[a, 1], green]]
    then sending the same 2 arrays to nextCartesianProduct would instead result in this: [[a, 1, red], [a, 1, green]]
    this exists so that more than 2 lists may be combined. see example that follows
example code for cartesianProduct and nextCartesianProduct:
    //you may copy this code as is and it will run
    var array1=cartesianProduct(['a', 'b', 'c'], [1, 2, 3]);
    writeln(array1.toSource()+'\n');
    //the output will is: [[a, 1], [a, 2], [a, 3], [b, 1], [b, 2], [b, 3], [c, 1], [c, 2], [c, 3]]
    writeln(nextCartesianProduct(array1, ['red', 'green', 'blue']).toSource());
    //the output is: [[a, 1, red], [a, 1, green], [a, 1, blue], [a, 2, red], [a, 2, green], [a, 2, blue], [a, 3, red], [a, 3, green], [a, 3, blue], [b, 1, red]...
alphaNumAscending(a, b), alphaNumDescending(a, b) and sumAscending(a,b)
    these are sorting functions in that they are meant to be sent to Array.sort
    these are the functions used for sorting internally with alphaNumAscending being ascending and alphaNumDescending being descending
    alphaNumAscending and alphaNumDescending are used for some DicePool functions and for numberGroup sorting. sumAscending is used for drawing functions
    Array.sort(alphaNumAscending).reverse()!=Array.sort(alphaNumDescending) which is why there are separate functions. although sumAscending can be reversed correctly
    <script>document.write(sumAscending);</script>  //entire code. [0] is the sum and [1] is the freq/chance. see Polynomial.createDiePolynomial for details
    alphaNumAscending and alphaNumDescending split the array into 2 sections as described in the basic description sorting section
    the numbers are always first (in either ascending or descending order) which is why one is not the reverse of the other
    the numbers are subtracted and the others are compared with &lt; and &gt;

<script>document.write(NamedDie);</script>  //alias/ short cut
<script>document.write(NamedDicePool);</script>  //alias/ short cut

rollDice(holder, nameArray) or rollDice(holder, firstName, secondName, ...)
    if there are more than 2 arguments it first converts the list of arguments into an array
    then it returns the sum of a roll with the dice specified
    full code: return new DicePool(holder, argumentsToArray(arguments, 1)).sumRoll(!Silent);
silentRollDice(holder, nameArray) or silentRollDice(holder, firstName, secondName, ...)
    if there are more than 2 arguments it first converts the list of arguments into an array
    then it returns the sum of a roll with the dice specified
    full code: return new DicePool(holder, argumentsToArray(arguments, 1)).sumRoll(Silent);

<script>document.write(FudgeDie);</script>  //alias
<script>document.write(StandardCoin);</script>  //alias
<script>document.write(Coin);</script>
Spinner = NamedDie;  //alias
MagicEightBall()  //short cut
    returns a NamedDie with the 20 Magic Eight Ball answers (see above)
<script>document.write(AskMagicEightBall);</script>  //shorthand
TwisterSpinner()  //short cut
    returns a NamedDie with the 16 Twister Spinner choices (see above)
<script>document.write(SpinTwisterSpinner);</script>  //shorthand. note: spin === roll
ScatterDie(alwaysScatter)
    Scatter Dice have a 1/3 change to be a direct hit and otherwise will scatter in a random direction
    if alwaysScatter is true then the 1/3 change of direct hit is ignored and will always scatter in a random direction
    alwaysScatter default is false.
    this outputs nothing and returns a string with the results with the scatter direction in degrees of whole numbers
    how to measure the degrees from is not specified. you might also need to round the number to something that can be more easily measured
    this can be called as a function which returns this.roll()
    this can also be created as an object which acts as a Die object and has the functions: roll(), isFudge(), getSides(), getStats(), and getName()
    compare to the die object for some of the rational. the reason why functions exist for it is to be used internally as a die object
    roll() is the same as calling ScatterDie as a function. it returns a string with either "Direct Hit" or "Scatter Direction: ? degrees"
    isFudge() returns false
    getSides() returns 360
    getName() returns "ScatterDie('+alwaysScatter+')" where alwaysScatter is whether or not it always scatters
    getStats()
       the values returned in the copy object are always the same:
       nameArray=[];
       isNegativeDice=false;
       doesUseZero=true;
       isFudge=false;
       sideCount=360;
       doesExplode=false;
       doesPenetrate=false;
       doesCompoundExplode=false;
       constantModifier=0;
       everything else is undefined
ScatterPool(alwaysScatter)
    alwaysScatter is false by default. it passes alwaysScatter to the ScatterDie
    if called as a function it creates a DicePool object with a ScatterDie(alwaysScatter) and 2d6 then returns the DicePool object
    otherwise (ie if created as an object) the only function it contains is:
    scatter(balisticSkill, isSilent)
       balisticSkill is 0 by default. isSilent is sent to DicePool.sumRoll(isSilent) for the 2d6
       if the scatter die is direct hit or if balisticSkill &gt;= the 2d6 roll then "Direct Hit" is returned
       otherwise a string is returned which contains the scatter die's direction and the distance in inches based on balisticSkill
    it does not contain roll() so that it will not be confused with DicePool objects
const AlwaysScatter = true;
    this is a defined global so that you may say ScatterDie(AlwaysScatter) or (!AlwaysScatter) instead of true or false
    this is simply more easy to read (!AlwaysScatter means "not AlwaysScatter" which is the value false)
const Silent = true;
    this is a defined global so that you may say DnDAttack(0, 20, 15, "1d10", 2, Silent) or !Silent) instead of true or false
    this is simply more easy to read (!Silent means "not Silent" which is the value false)

DnDAttack(attackBonus, minimumCritical, opposingAC, damageString, criticalMultiplier, areRollsSilent)
    This is for Dungeons and Dragons 3rd Edition (along with 3.5 and pathfinder).
    does what you'd expect: attackBonus is added to the attack roll when comparing against the opposingAC
    if the natural roll was &gt;= minimumCritical then it auto-hits and roll 1d20 vs opposingAC for a critical
    if critical damage rolled * criticalMultiplier. to turn off critical hits make criticalMultiplier = 1
    damageString will be given to silentRollDice so it needs to have correct syntax
    areRollsSilent is true by default. when areRollsSilent is false more information is recorded.
    nothing is written to the output. the information is in a string which is returned
    the return value if silent is in this form: [Critical] miss | (Attack | Critical hit) for x damage
    if it is not silent then the natural attack is always displayed first and the natural rolled for threat range is displayed right before "Critical hit"
L5RRoll(rollBonus, numberOfRaises, targetNumber, diceRolled, diceKept, hasEmphasis, areRollsSilent)
    does what you'd expect: rollBonus is added to the roll. rollBonus could be either any modifier to the total
    numberOfRaises will raise the targetNumber by 5 each. diceRolled and diceKept are as they sound: the number of dice you
    are rolling and the number of dice you will keep. it always keeps the highest ones
    hasEmphasis is false by default but if true will indicate to reroll 1s
    areRollsSilent is true by default. when areRollsSilent is false more information is recorded.
    nothing is written to the output. the information is in a string which is returned
    the return value if silent is in this form: Highest Total: x \n You (succeeded | failed) by y [\n Void recovered: z]
    if it is not silent then every value rolled is displayed (or "reroll" if applicable) then has "Values kept: x1 + x2... = y"
    instead of "Highest Total" and always displays "Void recovered" even when 0
IronClawDamage(damageDicePool, defenderDicePool, areRollsSilent)
    returns the results of the damage by giving it the damager and defender dice pools
    damageDicePool and defenderDicePool must be DicePool objects
    nothing is written to the output. the information is in a string which is returned
    areRollsSilent is true by default. when areRollsSilent is false more information is recorded.
    the return value will be either: Attacker Botched or (Defender Botched)? Damage Dealt: x where "Defender Botched" is optional and x is the total damage
    if areRollsSilent is false then every value of both rolls are displayed before every 1 is removed
    and then again after 1s are added so that each pool has the same number of dice
IronClawOpposedRoll(attackerDicePool, defenderDicePool, areRollsSilent)
    returns the results of an opposed roll that compares every value (from the highest to lowest) until one of the pools has a higher value
    attackerDicePool and defenderDicePool must be DicePool objects
    nothing is written to the output. the information is in a string which is returned
    areRollsSilent is true by default. when areRollsSilent is false more information is recorded.
    if the Attacker Botches then that is returned along with the Highest Defender value (this has priority over the defender botching)
    if the Defender Botches then that is returned along with the Highest Attacker value
    if the Attacker has a higher (or lower) max value than the Defender then the difference is shown as "Attacker (wins | loses) by x value"
    where x is the difference and | means or
    if the highest values are the same it moves on to compare the next highest until either a difference is found
    "You tied" will be returned if every die in each pool is the same value
    if areRollsSilent is false then every value of both rolls are displayed before every 1 is removed
    and then again after 1s are added so that each pool has the same number of dice
    every value compared is also displayed (if areRollsSilent is false)
BattleTechAttackMech(targetNumber, attackType, sideOfRobot, areRollsSilent)
    targetNumber is what number needs to be rolled on 2d6 in order to hit the target
    attackType must be either: "Missiles: x" where x is the number of missiles fired, "Punch", "Kick", or "Weapon" for all other weapons
    sideOfRobot must be either "Left", "Center", or "Right"
    areRollsSilent is true by default. when areRollsSilent is false more information is recorded.
    nothing is written to the output. the information is in a string which is returned
    first it determines if you hit. if areRollsSilent is false it records the attack rolled
    if you miss then that is returned and it stops there
    if the attackType was missiles it determines how many missiles hit, if rolls are not silent it records the rolled number
    then based on attackType (missiles hit the same locations as weapons) it determines where you hit the mech, if not silent it records the rolled number
    see BattleTechTables.robotHitLocations and BattleTechTables.robotPunchLocations below for information on hit locations
    then 2d6 is rolled to see how many critical hits would be landed assuming you hit internal armor, if not silent it records the rolled number
    unless the weapon hit location rolled a 2 (which is the only automatic critical) it reminds you that critical hits only apply if you hit internal armor
    if the determined number of critical hits (0 to 3) is not 0 then BattleTechMechCriticals is called with that number
    if not silent it records "Number of Criticals 0"
    if the number of critical hits would be 3 and the location is not a torso then it says "x blown off" instead
WarhammerAttackUnit(diceCount, toHitValue, toWoundValue, saveValue, areRollsSilent)
    diceCount is the number of 6 sided dice to be rolled for the attack
    toHitValue, toWoundValue, and saveValue represent the values the names suggest.
    if toHitValue or toWoundValue is greater than 6 it will return a string indicating the impossible
    saveValue has a default value of 7 meaning the unit can't save
    areRollsSilent is true by default. when areRollsSilent is false more information is recorded.
    nothing is written to the output. the information is in a string which is returned
    first it rolls a number of 6 sided dice equal to diceCount and sees how many were greater than or equal to the toHitValue
    then it rolls a number of 6 sided dice equal to the number of dice that hit comparing each to the toWoundValue in the same way
    then with the number that succeeded it rolls more 6 sided dice seeing if each are less than saveValue
    the number of wounds is indicated in the string returned
    the returned string may instead have a message such as 'None wounded'
    if areRollsSilent is false more information is recorded: each die's value is displayed for each roll
OneRollEngine(numberOfDice)
    numberOfDice is the number of 10 sided dice that will be rolled
    nothing is written to the output. the information is in a string which is returned
    the returned string will have the results sorted by Height ascending
    and be in the form of: AxB, CxD. where A-D are numbers and x is literal
BattleTechMechCriticals(numberOfCriticalHits)
    returns a string in the form of: (Upper | Lower) x; (Upper | Lower) y; ...
    where x and y etc are the number(s) rolled on 2d6 for hit location.
    the criticals will be rerolled until all of them are unique
    you may give it any number from 1 to 24. it is not aware of anything else including mech hit location (such as Left Arm)
    if given 3 it will not return that the limb should be blown off
BattleTech Functions for attacking vehicles and vehicle criticals are not included because I found conflicting tables online.

var BattleTechTables={};
    reserved. must exist to hold the tables but does nothing itself
BattleTechTables.robotHitLocations[sideOfRobot][silentRollDice("2d6")]
    used to determine where weapon hits the enemy mech
    sideOfRobot must be either "Left", "Center", or "Right"
    the second number is the result rolled on 2d6
    returns a string of the hit location in the form of: (Left | Right | Center) (Torso | Arm | Leg) | Head
    or if 2 was rolled either: "Left Torso (critical)", "Center Torso (critical)", or "Right Torso (critical)"
    undefined is returned if either the sideOfRobot or the number rolled was invalid
BattleTechTables.robotPunchLocations[sideOfRobot][silentRollDice("1d6")]
    used to determine where your punch lands on an enemy mech
    sideOfRobot must be either "Left", "Center", or "Right"
    the second number is the result rolled on 1d6
    returns a string of the hit location in the form of: (Left | Right | Center) (Torso | Arm) | Head
    undefined is returned if either the sideOfRobot or the number rolled was invalid
BattleTechTables.missileArray[misslesFired][silentRollDice("2d6")]
    used to determine how many missiles hit your target
    misslesFired is the number of missiles fired
    the second number is the result rolled on 2d6
    returns the number of missiles that hit
    undefined is returned if either the smisslesFired or the number rolled was invalid
Kicking does not have a table because it is so simple: "Left Leg" if on the left side, "Right Leg" if on the right and for center use:
    hitLocation=new Die("Left Leg", "Right Leg").roll();

var Draw={};
    reserved. must exist to hold the drawing functions but does nothing itself
    for any of the bell curves created that involve exploding dice it will stop when the last value has about 0.000% chance
Draw.diceBellCurve(poolGiven, secondColumn, binom)
    poolGiven must be a DicePool object. if there is any drop/keep then every die that non-compound explodes must have a minimum value of 1
    secondColumn is a string and is '&gt;=' by default. which is sent to Draw.generateDiceSumTable or Draw.generateBinomialTable along with the generated data
    binom must be a string indicating criteria that each die value is compared to
    an example of binom is '&lt;=3' which means: count the number of possible values that are less than or equal to 3
    if binom is given '='+number it will be changed to '=='+number so that eval may read it correctly
    each possible die value is sent to eval(value+binom) and count the number that are true
    binom can also be given a number which defaults to '=='+number
    if binom is provided then Draw.generateBinomialTable is called otherwise Draw.generateDiceSumTable is called
    nothing is written to the output or returned. see Draw.generateDiceSumTable and Draw.generateBinomialTable for more information
    the returned string of Draw.generateDiceSumTable or Draw.generateBinomialTable is then appended to the graph area
Draw.binomialBellCurve(trials, probability, secondColumn)
    secondColumn is a string and is '&gt;=' by default. which is sent to Draw.generateBinomialTable along with the generated data
    most of the code:
    rollData=generate_Binomials(trials, probability);
    Draw.generateBinomialTable(rollData, secondColumn);
    nothing is written to the output or returned. see generate_Binomials and Draw.generateBinomialTable for more information
    the returned string is then appended to the graph area
Draw.WarhammerBellCurve(diceCount, toHitValue, toWoundValue, saveValue, extraSaveValue, secondColumn)
    diceCount is the number of 6 sided dice to be rolled for the attack
    toHitValue, toWoundValue, and saveValue represent the values the names suggest.
    the extraSaveValue represents if the unit has an extra save (Reanimation Protocol or Feel No Pain) this is not the same thing as reroll failures
    set saveValue to 7 to represent that the unit can't save. extraSaveValue is 7 by default
    secondColumn is a string and is '&gt;=' by default. which is sent to Draw.generateBinomialTable along with the generated data
    nothing is written to the output or returned. see Draw.generateBinomialTable for more information
    the returned string is then appended to the graph area
Draw.generateDiceSumTable(rollData, secondColumn)
    secondColumn does not have a default (it must be provided) and if secondColumn is '=' it will become '==' instead
    rollData must be an 2D array each containing [value, freq or chance] where value is the sum of the dice, chance is the probability of getting that exact sum
    if a sum isn't possible is must be rollData[i][1]=0 to indicate not possible. but it must be defined
    and freq is the number of possible ways that sum can be rolled. the probability is calculated based on summing the frequencies
    you may use freq or chance but they must all be one or the other not both
    an html table is returned as a string with the percent chances rounded to 3 places
    the green bar of the table is the most likely. there might be more than one green bar
    rounding may cause 2 numbers to be the same but only 1 of them is green which means that without rounding the green one is slightly greater
    the table will not contain rows that have freq/chance of exactly 0. if you want the row to display as 0 then make
    rollData[i][1]=0.000001 (so that it rounds to 0% but isn't 0) this only works for chances and there is no freq equivalent
    above the table there are also some statistics: Min (Minimum Sum), Max (Maximum Sum), Avg (Average Sum), Std Dev (Standard Deviation)
Draw.generateBinomialTable(rollData, secondColumn)
    secondColumn does not have a default (it must be provided) and if secondColumn is '=' it will become '==' instead
    rollData must be a 1D array where the array index represents the number of successes and the array value is the probability of getting that result
    all values of the array must be defined. to represent an impossible number use rollData[i]=0
    Draw.generateDiceSumTable is called after some overhead. see Draw.generateDiceSumTable for more information
    the html is returned as a string
Draw.compareDiceBellCurve(dicePoolLeft, dicePoolRight)
    pass in 2 DicePool objects. It will calculate the probabilities for each pool.
    it will then take right minus left as the new probability and draw it.
    the left is in red (negative) and right is blue (positive).
    larger bar means the difference in probability is great.

var Polynomial={};
    reserved. must exist to hold the polynomial functions but does nothing itself
    each polynomial function is used by drawing functions (see above) to generate the rollData
    all polynomials are 2D arrays with each element [constant, exponent]
    for example x^3 + 2x - 3x^5 + x^-2 + 5 is [[1, 3], [2, 1], [-3, 5], [1, -2], [5, 0]]
    for the formula for why polynomials can represent dice sums see <a href='http://mathforum.org/library/drmath/view/52207.html'>Math Reference</a>
    this approach will work fast at finding every possible sum but will not work for named dice and drop/keep
Polynomial.createDiePolynomial(dieObject, explodeCount)
    given a Die object (dieObject) and the number of times you want it to be able to explode (explodeCount) it generates all values as a polynomial
    the first value (the constant) represents the die's value
    the second value (exponent) represents either the freq if there are no explosions (explodeCount is 0 or dieObject doesn't explode) or the chance otherwise
    the result is returned and the dieObject isn't changed
Polynomial.addPolynomials(poly, value, freq)
    poly must be a 2D array. it must be a polynomial
    value and freq are the elements of the new element you want to be added
    freq can be either a frequency or probability (mutually exclusive): either way functions the same
    it searches poly to find that freq and adds value to it's value if found
    if not found poly.push([value, freq])
    poly does not need to be sorted in any way. poly is changed and nothing is returned
Polynomial.multiplyPolynomials(polyNomGiven, myPool)
    polyNomGiven must be an array of polynomials (making it a 3D array)
    each polynomial is multiplied together then each common term is added together
    for example: (2x^2 + 2)*(x^2 - 2) = 2x^4 - 2x^2 - 4
    myPool is the DicePool used to generate the polynomials. it is used for min/max and constant modifiers
    if myPool is undefined it will default to an empty DicePool which will have no impact on the results
    the result is returned. polyNomGiven and myPool are not changed

groupParser(groupString)
    work in progress. do not call because it is not tested or finished
findFirstCompleteCurlyBrackets(totalString)
    a utility used for groupParser. it is done and works fine
    it finds the first '}' then the closest '{' that comes before it
    the return value is [beforeText, innerText, afterText] where each are strings
    with pieces of totalString either before, after, or inside those braces
    the innerText does not have {} any more
numberGroup(diceStringGiven)
    if numberGroup is called as a function it will return the diceStringGiven that remains after the constructor (diceStringGiven doesn't change)
    see the object documentation below for details
</pre>
<h3>Predefined objects and the functions they contain</h3>
<pre>
Die(diceStringGiven, nameArray)
{
    this object represents a single die of any kind except Scatter Die.
    the roll function is the only one that does not simply return read-only information about the die

    hasNames()
       returns true if the die uses the nameArray, ie if it is a named die
    setName(nameGiven)
       gives this die a name. not to be confused with the nameArray which represents the value of each side
       instead the nameGiven has no impact on the die's functionality and is only used when calling getName
    getName()
       returns the name if it has been set otherwise generateString is called
    generateString()
       returns a string that represents the details of the die
       if the string is sent to a Die constructor a duplicate will be created
       this assumes that the die is not named, if nameArray is not empty then generateString simply returns the number of sides
    equals(otherDie)
       returns true if each of the stats (see getStats) of this is the same as otherDie
       the exception is that the die's name (see setName) is not considered
       if the dice are named dice each element of nameArray is compared
    getStats()
       returns an object that has a copy of every attribute of this die
       the object returned is not a die object and only has copies of the values so that these values can't be changed
       keep in mind that rerolling is optimized which may make some of the following attributes different than expected
       the attributes of die (that are returned by getStats) are as follows:
       nameArray: (a copy is made) empty by default. this contains the values of each of the die's sides if it is a named die
       isNegativeDice: false by default. this indicates if the die is positive or negative. if negative the result rolled will be negative
       doesUseZero: false by default. this indicates if the die starts at zero instead of 1. this is also true for fudge dice
       isFudge: false by default. this indicates if the die is a fudge die which is numbered -1, 0, 1
       sideCount: 0 by default although it is never possible to have such a die since an error will be thrown instead.
          this indicates the number of possible values the die has
       doesExplode: false by default. this indicates if the die explodes by adding another die. this is true for doesPenetrate but not doesCompoundExplode
       doesPenetrate: false by default. when true, 1 is subtracted from each die added due to explosions
       doesCompoundExplode: false by default. when true, the explosions are considered a single die value. mutually exclusive with doesExplode
       dieName: undefined by default. has no meaning and is only set by setName
       rerollCriteria: undefined by default. reroll optimizing may cause this value to be different than expected
          undefined indicates that there are no values that are rerolled otherwise it is a string with a logical numerical comparison followed by a number
          so that eval(''+valueRolled+rerollCriteria) is true. it is copied from the constructor directly following the 'r'
       explodeValue: undefined by default. reroll optimizing may cause this value to be different than expected
          this is the value that will cause an explosion. because of this is can't be the final result of a roll
       constantModifier: 0 by default. reroll optimizing may cause this value to be different than expected
          this is a constant modifier that is added to each value rolled before reroll but after explosions are determined
    isFudge()
       returns true if the die is a fudge die
    getMaxValue()
       returns the value which is on the last side of the die which is also the maximum possible value unless it is a named die
       if it is a named die is just returns the name of the last side regardless of whether or not it is the maximum value
    getMinValue()
       returns the value which is on the first side of the die which is also the minimum possible value unless it is a named die
       if it is a named die is just returns the name of the first side regardless of whether or not it is the minimum value
    getSides()
       returns the number sides the die has
    flip() or spin()
       these are both aliases for roll() (since Die could also be called a coin or spinner)
    roll()
       outputs nothing but returns a random possible side. the name of the side is returned if it exists
       otherwise the side value is returned. coin starting at 0 and fudge die have been accounted for
       if the die explodes (not compound) then an array of every rolled value is returned
       compound exploding and penetrating exploding have been accounted for
    constructor()
       although not a function that can be called it is listed here to show all the different ways the Die object can be created using the keyword new
       Die() using this will make a standard 6 sided die
       Die(diceString) this will make the die as normal ie as specified by the string. it will not be a named die.
          for details on the diceString see the "basic description" at the top. the differences for diceString are: must contain only a single die with
          an optional 1, must not indicate a scatter die, and must not contain min/max, drop/keep or sorting
       Die(name1, name2, ...) if given 2 or more arguments, each argument will be used as the value of each side of a named die just like nameArray
          names may be passed as anything objects, strings, numbers etc
       Die(nameArray) given an array each elements will be used as the value of each side of a named die. an array with a single string element is the only way
          to get a single sided named die since normally a single parameter (except an array) would be read as diceString
}
DicePool(diceStringGiven, nameArray)
{
    dice pool is an object that holds an array of dice and some other functionality.
    it is not a wrapper but contains new functions that do not exist elsewhere

    first some static members:
    DicePool.minMaxRegexStart = /^\s(?:with\s)?(?:a\s)?(?:min|max)(?:imum)?\s(?:of\s)?/;
    DicePool.dropKeepRegexShortHand = /^[dk][hl]?\d*/;
    DicePool.dropKeepRegexStart = /^\s(?:drop(?:ping)?|remov(?:e|ing)|ignor(?:e|ing)|keep(?:ping)?)/;

    setName(nameGiven)
       gives this dice pool a name. the nameGiven has no impact on the dice pool's functionality and is only used when calling getName
    getName()
       returns the name if it has been set otherwise generateString is called
    generateString()
       returns a string that represents the details of the dice pool
       it calls generateString for each die contained in the dice pool then it adds dice pool information
       if the string is sent to a Dice Pool constructor a duplicate will be created
    getAllDice(){return diceArray.slice();};  //copies array so that it is read only
       returns an array of die objects which this pool contains
    getStats()
       returns an object that has a copy of every attribute of this dice pool
       the object returned is not a dice pool object and only has copies of the values so that these values can't be changed
       keep in mind that this does not include the stats of the dice contained. for that you must call getStats for each die in diceArray
       the attributes of dice pool (that are returned by getStats) are as follows:
       nameArray is not returned since it would always be empty. instead see the stats of each die contained
       diceArray: empty by default. (a copy is made) this is the array that contains every die that is in the dice pool including scatter die
       constantModifier: 0 by default. this is a constant modifier that is added as the first element of any roll so that it will be added to the sum
       allFudge: false by default. this represents whether or not every die in the dice pool is a fudge die
       outsource: an empty numberGroup object by default. see numberGroup for more information
       poolName: undefined by default. has no meaning and is only set by setName
       rolledValues: an empty object by default. (a copy is made) whenever roll() is called this object is created which holds everyRoll and droppedRolls
          everyRoll is an array that is the same as the one returned by roll()
          droppedRolls is an array that contains every die value that was dropped due to drop/keep. it may be empty
          if roll has not been called since the last time this dice pool was changed then each everyRoll and droppedRolls are undefined
    generateSumString(everyRoll, droppedRolls)
       returns a string formatting the results of a dice roll
       everyRoll and droppedRolls must be arrays of numbers although droppedRolls is optional
       the string will be a list of everyRoll values with + separating them
       it will display the total after min/max, the removed values and the previous total before min/max
       if all the dice are fudge the sign will be displayed without separation such as: "+-0+ = 1"
       named dice will be separated by comma in the dice list and not be counted for the total
    add(newDiceStringPassed, nameArray)
       used to add dice to the dice pool. called by the constructor but may also be called elsewhere
       newDiceStringPassed must have correct syntax for a Die object (diceStringGiven) except that
       if multiple dice are indicated they will be parsed into multiple Die objects
    addDie(newDieObject)
       adds the given die to the pool
       newDieObject must be a Die object
    addAllDice(newDice)
       adds the given dice to the pool
       newDice must be either an array of Die objects or a DicePool object
       if newDice is a DicePool object then getAllDice() will be called
       no other properties from the other DicePool will be used
    getSize()
       returns the number of dice in the pool
    roll()
       rolls every die in the pool and returns an array of those values
       all forms of exploding have already been accounted for and so has drop/keep
       this outputs nothing and does not find the total hence min/max is not performed
    sumRoll(isSilent)
       returns roll().summation() with min/max accounted for
       isSilent is true by default but if it is false then this will call writeln(generateSumString(everyRoll, droppedRolls));
    countSuccessesRoll(successCriteria, failureCriteria, areRollsSilent)
       rolls the dice pool and adds the number of dice that meat the successCriteria, subtracting the ones that meat the failureCriteria
       it returns a string with the results
       failureCriteria is optional and areRollsSilent is true by default. if you would like to set areRollsSilent without setting
       failureCriteria give it something absurd or pass it undefined
       the criterias must be something that is evaluated numerically such as ">3"
       a number must be given. if a number is given but no comparison operated then "==" is used by default
       if "=" is the comparison operated then it will be changed to "==" to meat the javascript standards
       the returned string says the number of net successes or failures or if it come up even
       if areRollsSilent is false then it will also display every roll followed by each value's comparisons
       then the total Successes, total Failures then the net total
    opposedRollByDice(otherDicePoolObject, failurePenalty, areRollsSilent)
       this rolls both dice pools counting the number of dice that have higher or lower values
       otherDicePoolObject must be a Dice Pool object and failurePenalty and areRollsSilent must be true or false
       failurePenalty is true by default and areRollsSilent is true by default
       both dice pools are rolled then their values are sorted descending
       the highest die in each pool is compared and if this is higher or lower it increases a respective counter (by 1)
       note that in each opposed roll is compared with &gt; followed by &lt; which means that named dice will be compared by name length
       if failurePenalty is false and this has a lower die than the other pool then nothing happens (ie there is no failure counter)
       the return value is a string indicating how many dice you (this) lost or won by or if i was a tie
       if areRollsSilent is false then the returned string also contains a list of every die from each pool
    opposedSumRoll(otherDicePoolObject, areRollsSilent)
       same as opposedRollByDice except that this compares the sum of each pool's rolls instead of each die
       the return value is a string indicating whether you win, lose, or tie
       if areRollsSilent is false then the returned string also contains each total value
    opposedRollByBestValue(otherDicePoolObject, areRollsSilent)
       same as opposedSumRoll except that this compares each pool's best value instead of the sums
       note that in each opposed roll is compared with &gt; followed by &lt; which means that named dice will be compared by name length
       if the best dies are the same value then it goes to the next best value and so on
       it returns a string that says the difference between the values that were different
       missing dice are considered a value of 0
       if areRollsSilent is false the returned string also contains the dice values compared
    constructor()
       although not a function that can be called it is listed here to show all the different ways the DicePool object can be created using the keyword new
       DicePool() this creates an empty dice pool that does not contain any dice and all values are default
       DicePool(diceString) this will make each die as normal ie as specified by the string.
          for details on the diceString see the "basic description" at the top
       DicePool(numberOfDice, name1, ...) or DicePool(numberOfDice, nameArray) will create add a number of dice equal to numberOfDice. each added die is
          named using the other parameters passed see the Die constructors for details
       DicePool(DicePoolGiven) this is not a copy constructor. addAllDice is called with DicePoolGiven then finish
       DicePool(DieGiven) given either a Die or ScatterDie object will have it call addDie then finish
}
numberGroup(diceStringGiven)
{
    this is part of DicePool that has been outsourced to handle drop/keep, min/max, and sorting
    diceStringGiven is the string containing the information for these functions such as " drop lowest 1 min 6"

    getStats()
       returns an object that has a copy of every attribute of this numberGroup
       the object returned is not a numberGroup object and only has copies of the values so that these values can't be changed
       the attributes of numberGroup (that are returned by getStats) are as follows:
       dropKeepSwitch: "None" by default also ignored if dropKeepValue is 0. the possible values are "Drop" and "Keep".
       lowHighSwitch: "None" by default also ignored if dropKeepValue is 0. the possible values are "Low" and "High".
          the combination of dropKeepSwitch and lowHighSwitch must be used to determine which way to sort the values and how many to remove
       dropKeepValue: 0 by default. the number of values that will be either dropped or kept
       minMaxSwitch: "None" by default. the other possible values are "Min" and "Max" which indicate if min/max is
          used and which one will be used
       minMaxValue: 0 by default although it must be assigned a value if min/max is used. the number assigned may be 0
       sortDirection: "None" by default. the other possible values are 'a' and 'd' which stands for ascending and descending.
          note that all values are sorted alphabetically and numerically not only the numbers
    dropDoing(everyRoll)
       everyRoll is an array of numbers that contains every value that was rolled after explosions, reroll, and everything except min/max
       this will drop the correct number of dice or throw an error if not enough values exist
       it ignores all values that are NaN which will always remain in everyRoll
       everyRoll will be changed (if needed) and the return value is an array of every value dropped
       this function also handles sorting. if none then everyRoll will remain in the same order with some removed
       DicePool.roll() calls this then adds the constant (if any) then sumRoll calls minMaxDoing
       this is also called other places internally
    minMaxDoing(total)
       total is a number that is compared to the min or max value
       the correct possible total is returned instead (possibly the same number)
       this is called by DicePool.sumRoll() and other places internally
    constructor()
       although not a function that can be called it is listed here for clarity
       there is only one kind of constructor which is passed a string that contains things from diceString: min/max, drop/keep, and sorting
       if the string does not start with shorthand then it must start with a space (or be empty)
}
For those who know javascript and want to know more than this information has provided, look at the code yourself: everything is included in this 1 file.
</pre></div>
<br /><br /><br /><br />
<script>document.getElementById('inputCode').focus();</script>
</body>
</html>
