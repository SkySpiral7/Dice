<!DOCTYPE HTML>
<html>
<head>
   <meta charset="UTF-8" />
   <title>Material Hunt Stats - MHW</title>
   <script id="DiceInclude" src="../javascript/Include.js"></script>
   <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.0/themes/base/jquery-ui.css" />
   <style>
      /*Style based on the H&H css but with red hover and blue links*/

      /*classes autocomplete etc are from jquery-ui*/
      html, body, input, textarea, select, button,
      .ui-autocomplete .ui-menu-item .ui-menu-item-wrapper {
         background-color: black;
         border-color: #202020;
         color: #A0A0A0;
      }

      .ui-autocomplete .ui-menu-item .ui-menu-item-wrapper.ui-state-active {
         background-color: #000040;
      }

      ::-webkit-scrollbar {
         background-color: #101010;
      }

      ::-webkit-scrollbar-thumb {
         background-color: #202020;
      }

      a:link, a:visited {
         color: #79AAFF;
      }

      p {
         max-width: 1000px;
      }

      h2 {
         font-size: 28px;
      }

      .hoverInfo {
         color: red;
         border-bottom: 1px dotted red;
      }
   </style>
   <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4="
           crossorigin="anonymous"></script>
   <script src="https://code.jquery.com/ui/1.13.0/jquery-ui.min.js" integrity="sha256-hlKLmzaRlE8SCJC1Kw8zoUbU8BxA+8kR3gseuKfMjxA="
           crossorigin="anonymous"></script>
   <script>
      'use strict';

      /* Data validations:
       * 1 A tail can't both break and be severed
       * 2 Only a tail can be severed
       * 3 Rewards: Capture is same as Carves: Carves
       * 4 each table adds up to 100% (won't affect calculations but would be good to verify non bad data)
       * 5 LR monsters will have HR and MR fights
       * 6 HR monsters will have MR fights except ['Ancient Leshen', 'Leshen'] which are event only
       * 7 LR can't have purple investigation
       * 8 if a monster can be fought at rank then it must have all tables I look for (including investigations) except tail/breaks
       * 9 There will not be duplicate tables (auto ignores the rest)
       * 10 there will not be duplicate material of same count in a table
       * 11 monsters have the same breakable parts (including sever tail) at every rank
       * 12 every monster will have at least 1 break (excluding sever tail). if missing this is assumed partial data
       *
       * Ask data:
       * 1 are there any tables with duplicate material of diff count
       * 2 are there any monsters who are MR only? looks like fatalis and safi-jiiva
       * 3 is each table highest % to least order? if not I could sort them for default material
       *
       * Data corrections:
       * 1 ignore duplicate tables keeping only the first
       * 2 ignore partial rank data
       * 3 if sever and break tail then keep the sever
       * 4 if kill/capture tables don't match keep the kill (the capture tables I saw were all Monster Bone L 100%)
       * 5 Kushala Daora and Teostra don't have breakable forelimbs
       * 6 Safi'jiiva Master Rank Rewards > Capture Safi'jiiva Safi'jiiva Shard x1 22% should be Safi'jiiva Cortex to match the Kill table
       * 7 Ancient Leshen/Leshen don't have Investigations and are thus ignored. Leshen HR Bronze was the only one that looked valid anyway
       * 8 Nergigante doesn't have LR rewards. Break might be possible but I can't confirm that
       * 9 I made a list of LR monsters. LR data from a monster not in the list is ignored
       *
       * Assumptions (don't affect calc):
       * 1 Bandit Mantle only gives trade-in items (pretty sure the game says this)
       * 2 some monsters are not in low rank (I know this 1)
       * 3 some monsters are not in high rank (probably but not sure)
       * 4 master rank can fight everything and high can fight all low
       *
       * Notes:
       * 71 total monsters (including Zorah)
       */
      //TODO: store data offline (more legit) then validate it and correct Zorah
      /** Elder Dragons can't be captured. LR Kirin stood on the trap without it triggering.
       * Zorah is out and Nergigante so far is story only. Don't know if other Elder dragons have other issues but they can get normal and purple Investigations.
       * Currently this is only used to ignore capture table validation for which Zorah is ignored but he is in fact an ED and definitely can't be captured normally. */
      const elderDragons = [
         'Alatreon', 'Behemoth', 'Blackveil Vaal Hazak', 'Fatalis', 'Kirin', 'Kulve Taroth', 'Kushala Daora', 'Lunastra', 'Namielle',
         'Nergigante', 'Ruiner Nergigante', 'Safi\'jiiva', 'Shara Ishvalda', 'Teostra', 'Vaal Hazak', 'Velkhana', 'Xeno\'jiiva',
         'Zorah Magdaros'
      ];
      const noInvestigations = ['Ancient Leshen', 'Leshen'];
      /** These are the only monsters that are possible for low rank. Kirin can get LR investigations in addition to the LR optional quest.
       * Nergigante and Zorah Magdaros are story only (no LR investigations). Zorah is ignored and Nergigante is excluded since you can't
       * get LR rewards from him (see data corrections) */
      const lowRankMonsters = [
         'Anjanath', 'Barroth', 'Diablos', 'Great Girros', 'Great Jagras', 'Jyuratodas', 'Kirin', 'Kulu-Ya-Ku', 'Legiana',
         'Odogaron', 'Paolumu', 'Pukei-Pukei', 'Rabodaan', 'Rathalos', 'Rathian', 'Tobi-Kadachi', 'Tzitzi-Ya-Ku', 'Zorah Magdaros'
      ];
      //I haven't finished HR yet so there'll be more on this list later. ignore for now
      /*
      const highRankMonsters = [
         'Anjanath', 'Barroth', 'Great Girros', 'Jyuratodas', 'Kulu-Ya-Ku',
         'Paolumu', 'Pukei-Pukei', 'Rabodaan', 'Rathian', 'Tobi-Kadachi', 'Tzitzi-Ya-Ku', 'Zorah Magdaros'
      ];
      */
      const monsterData = {};
      //markBadData for auto corrected issues and console.error for ones that are unexpected
      const badData = {monsters: []};

      /** Builds monsterData via web scraping. It's faster than I expected but rarely if ever needs to be reran.
       *
       * After running manually check:
       * 1 that there are no console.error else add more corrections
       * 2 run groomMonsterData then JSON.stringify(monsterData) chrome will offer to put in clipboard
       *
       * Last run on 2021-12-23 ? the website says ver. 15.11
       * Latest game version is 15.11.01 (2021-06-03) */
      function scrapeMonsterList()
      {
         /**This disables jquery from requesting images when parsing html*/
         const virtualDocument = document.implementation.createHTMLDocument('virtual');

         $.get('https://mhworld.kiranico.com/monsters').fail(() =>
         {
            alert('Failed to load https://mhworld.kiranico.com/monsters (the monster index).\nConnect to internet and try again.');
         })
         .done(function(html)
         {
            $(html, virtualDocument).find('h6:contains("Large Monsters")+div>div>table a').each((index, element) =>
            {
               const monsterName = element.textContent;
               //exclude all of Zorah Magdaros (RTFM for reason)
               if('Zorah Magdaros' !== monsterName)
                  scrapeMonsterData(virtualDocument, monsterName, element.href);
            });
         });
      }

      /* Debug example:
       * scrapeMonsterData(document.implementation.createHTMLDocument('virtual'), 'Nergigante', 'https://mhworld.kiranico.com/monsters/aYaUV/nergigante')
       * scrapeMonsterData(document.implementation.createHTMLDocument('virtual'), 'Alatreon', 'https://mhworld.kiranico.com/monsters/ErdcV/alatreon')
       * scrapeMonsterData(document.implementation.createHTMLDocument('virtual'), 'Rathalos', 'https://mhworld.kiranico.com/monsters/BnetX/rathalos')
       * scrapeMonsterData(document.implementation.createHTMLDocument('virtual'), 'Silver Rathalos', 'https://mhworld.kiranico.com/monsters/B0ktO/silver-rathalos')
       * scrapeMonsterData(document.implementation.createHTMLDocument('virtual'), 'Ancient Leshen', 'https://mhworld.kiranico.com/monsters/N3vuk/ancient-leshen')
       */
      function scrapeMonsterData(virtualDocument, monsterName, monsterUrl)
      {
         $.get(monsterUrl).fail(() =>
         {
            console.error('Failed to load ' + monsterUrl);
         })
         .done(function(html)
         {
            /*Example:
               {
                  General: {Kill: [], Capture: [], Hunt: []},
                  Break: {tail: [], horn: [], horns: []},
                  Sever: {tail: []},
                  Investigation: {Bronze: [], Silver: [], Gold: [], Purple: []}
               }
               each one has {material: 'M Scale', itemCount: 1, probability: 0.05}
               Investigation.Purple won't be created for LR
               Break is populated only by parts found (including some tail)
               Sever is only for some tail and is deleted if empty
               Capture is only for validation and is deleted before done
            */
            monsterData[monsterName] =
               {
                  'Low Rank': {General: {}, Break: {}, Sever: {}, Investigation: {}},
                  'High Rank': {General: {}, Break: {}, Sever: {}, Investigation: {}},
                  'Master Rank': {General: {}, Break: {}, Sever: {}, Investigation: {}}
               };
            const materialForMonster = {};
            //partsPerRank is for validation
            const partsPerRank = {
               'Low Rank': {},
               'High Rank': {},
               'Master Rank': {}
            };
            const oldToNewStructure =
               {
                  'Carves': {'Carves': {section: 'General', table: 'Kill'}, 'Tail Carved': {section: 'Sever', table: 'tail'}},
                  //Carves: Carves is same as Rewards: Capture include both for validation
                  'Rewards': {
                     [`Capture ${monsterName}`]: {section: 'General', table: 'Capture'},
                     [`Hunt ${monsterName}`]: {section: 'General', table: 'Hunt'}
                  },
                  //quest table not from this page
                  'Investigations':
                     {
                        'Investigation Reward (Bronze)': {section: 'Investigation', table: 'Bronze'},
                        'Investigation Reward (Silver)': {section: 'Investigation', table: 'Silver'},
                        'Investigation Reward (Gold)': {section: 'Investigation', table: 'Gold'},
                        'Investigation Reward (Purple)': {section: 'Investigation', table: 'Purple'}
                     }
               };

            //delete unused structure
            if(!lowRankMonsters.includes(monsterName)) delete monsterData[monsterName]['Low Rank'];

            $(html, virtualDocument).find('h6').each((index, sectionSearch) =>
            {
               const sectionText = sectionSearch.textContent;
               //if not a section to keep then continue
               if(!oldToNewStructure[sectionText]) return;  //html looping sectionSearch

               const section = sectionSearch.nextElementSibling;
               $(section, virtualDocument).find('h6').each((index, rankSearch) =>
               {
                  const rankText = rankSearch.textContent;
                  //ignore empty cols
                  if(!rankSearch.nextElementSibling) return;  //section looping rankSearch
                  //if data exists where it shouldn't
                  if('Nergigante' === monsterName && 'Low Rank' === rankText)
                  {
                     markBadData(`Manual Correction: no rewards at Low Rank`, monsterName);
                     //ignore table
                     return;  //section looping rankSearch
                  }
                  if(!monsterData[monsterName][rankText])
                  {
                     markBadData(`Wrong rank data: monster can't be fought at ${rankText}`, monsterName);
                     //ignore table
                     return;  //section looping rankSearch
                  }

                  const rankCol = rankSearch.parentElement;
                  //the table name is actually a td and not th
                  $(rankCol, virtualDocument).find('td').each((index, tableSearch) =>
                  {
                     const tableText = tableSearch.textContent.trim();
                     let thisPartName = undefined;
                     //I suppose I could hard code all possible part names but startsWith works fine
                     if(tableText.startsWith('Break ' + monsterName + '\'s '))
                     {
                        //should already be lowercase but enforce it
                        thisPartName = tableText.substring(('Break ' + monsterName + '\'s ').length).toLowerCase();
                     }
                     //tail is covered as a normal table
                     else if('Tail Carved' !== tableText && tableText.contains(' Carved'))
                     {
                        console.error(`Assumption violation: can sever non tail of ${monsterName}`);
                        return;  //rankCol looping tableSearch
                     }
                     //if not a table to keep then continue
                     else if(!oldToNewStructure[sectionText][tableText]) return;  //rankCol looping tableSearch
                     //else parse it

                     // td > tr > tbody > table
                     const table = tableSearch.parentElement.parentElement.parentElement;

                     let percentSum = 0;
                     let dataLocation = undefined;
                     const newStructure = oldToNewStructure[sectionText][tableText];
                     //non-breaks including sever tail is handled here
                     if(newStructure)
                     {
                        if(noInvestigations.includes(monsterName) && 'Investigation' === newStructure.section)
                        {
                           markBadData(`Manual Correction: wrong Investigation`, monsterName);
                           //ignore this table
                           return;  //rankCol looping tableSearch
                        }
                        if(monsterData[monsterName][rankText][newStructure.section][newStructure.table])
                        {
                           //uses new table names so that it doesn't include monster name "Capture X"
                           markBadData(`Duplicate new table ${rankText} ${newStructure.section} > ${newStructure.table}`, monsterName);
                           //ignore this table (keeping the previous data)
                           return;  //rankCol looping tableSearch
                        }
                        if('Low Rank' === rankText && 'Investigation' === newStructure.section && 'Purple' === newStructure.table)
                        {
                           console.error(`Assumption violation: ${monsterName} has Low Rank Investigation > Purple`);
                           //ignore this table
                           return;  //rankCol looping tableSearch
                        }

                        dataLocation = monsterData[monsterName][rankText][newStructure.section][newStructure.table] = [];
                     }
                     //all breaks including break tail is handled here
                     else if(thisPartName)
                     {
                        if(['Teostra', 'Kushala Daora'].includes(monsterName) && 'forelimbs' === thisPartName)
                        {
                           markBadData('Manual Correction: wrong breakable part', monsterName);
                           //ignore this table (not a real breakable part)
                           return;  //rankCol looping tableSearch
                        }
                        if(monsterData[monsterName][rankText]['Break'][thisPartName])
                        {
                           //uses new table names so that it doesn't include monster name "Break X's head"
                           markBadData(`Duplicate new table ${rankText} Break > ${thisPartName}`, monsterName);
                           //ignore this table (keeping the previous data)
                           return;  //rankCol looping tableSearch
                        }

                        partsPerRank[rankText][thisPartName] = true;
                        dataLocation = monsterData[monsterName][rankText]['Break'][thisPartName] = [];
                     }
                     else
                     {
                        //must stop because it would cause NPE
                        alert(`Programming bug: unmapped table: ${monsterName} ${rankText} ${sectionText} > ${tableText}`);
                        //throw in order to stop scrapeMonsterData instead of just the table
                        throw new Error(`Programming bug: unmapped table: ${monsterName} ${rankText} ${sectionText} > ${tableText}`);
                     }

                     const materialInTable = {};
                     $(table, virtualDocument).find('span').each((index, materialSearch) =>
                     {
                        let material = materialSearch.textContent;
                        const materialLink = materialSearch.parentElement;
                        let materialCount = 1;
                        if(null !== materialLink.nextSibling && 0 !== materialLink.nextSibling.textContent.trim().length)
                        {
                           materialCount = Number.parseInt(materialLink.nextSibling.textContent.replace(' x', ''));
                        }
                        const materialPercentElement = materialLink.parentElement.nextElementSibling.textContent;
                        const materialPercentNumber = Number.parseInt(materialPercentElement.replace('%', ''));
                        percentSum += materialPercentNumber;
                        const materialProbability = materialPercentNumber / 100;

                        if('Safi\'jiiva' === monsterName && 'Capture Safi\'jiiva' === tableText &&
                           'Safi\'jiiva Shard' === material && 22 === materialPercentNumber)
                        {
                           /* correcting this also would cause Kill/capture to match so that bad data doesn't trigger
                            * although it wouldn't trigger anyway since this is an Elder Dragon */
                           material = 'Safi\'jiiva Cortex';
                           markBadData('Manual Correction: wrong material', monsterName);
                        }
                        //material can be in table more than once if it has different counts
                        if(materialCount === materialInTable[material])
                           console.error(`Assumption violation: ${monsterName} ${rankText} ` +
                              `${sectionText} > ${tableText} duplicate material: ${material} x${materialCount}`);

                        materialForMonster[material] = true;
                        materialInTable[material] = materialCount;

                        dataLocation.push({
                           material: material,
                           itemCount: materialCount,
                           probability: materialProbability
                        });
                     });

                     if(100 !== percentSum)
                        console.error(`Assumption violation: ${monsterName} ${rankText} ` +
                           `${sectionText} > ${tableText} doesn't add up to 100%`);
                  });
               });
            });

            //true when a rank has 1 table but not all of them
            let partialRank = false;
            //have to wait for entire data because these are in different sections
            ['Low Rank', 'High Rank', 'Master Rank'].forEach(rank =>
            {
               /* If this rank might exist (non-LR) but has no data then delete rank.
                * LR is already deleted for non-LR monsters so they won't enter here.
                * Actual LR monsters shouldn't be missing everything.
                * HR/MR needs to validate Purple and the rest.
                * Therefore Purple doesn't need special handling. */
               if(monsterData[monsterName][rank] &&
                  !hasTable(monsterName, rank, 'General', 'Kill') &&
                  !hasTable(monsterName, rank, 'General', 'Capture') &&
                  !hasTable(monsterName, rank, 'General', 'Hunt') &&
                  0 === Object.keys(monsterData[monsterName][rank].Break).length &&
                  !hasTable(monsterName, rank, 'Sever', 'tail') &&
                  !hasTable(monsterName, rank, 'Investigation', 'Bronze') &&
                  !hasTable(monsterName, rank, 'Investigation', 'Silver') &&
                  !hasTable(monsterName, rank, 'Investigation', 'Gold') &&
                  !hasTable(monsterName, rank, 'Investigation', 'Purple'))
               {
                  delete monsterData[monsterName][rank];
               }

               //if monster still has this rank. don't connect with else since LR is already deleted
               if(monsterData[monsterName][rank])
               {
                  /* If these 2 tables are different. Elders can't be captured so ignore Capture table.
                   * It's debatable if elders should have the same capture table or none so don't mark as invalid. */
                  if(!elderDragons.includes(monsterName) &&
                     JSON.stringify(monsterData[monsterName][rank].General.Kill) !==
                     JSON.stringify(monsterData[monsterName][rank].General.Capture))
                  {
                     markBadData(`Kill/Capture tables don't match for ${rank}`, monsterName);
                     //no action: keep kill and Capture is always deleted anyway to save space
                  }
                  delete monsterData[monsterName][rank].General.Capture;

                  //tail is only possible sever if not there then delete sever
                  if(!monsterData[monsterName][rank].Sever.tail)
                     delete monsterData[monsterName][rank].Sever;
                  //has Sever.tail
                  else if(monsterData[monsterName][rank].Break.tail)
                  {
                     markBadData(`Break and sever tail at ${rank}`, monsterName);
                     //assume that sever is correct
                     delete monsterData[monsterName][rank].Break.tail;
                  }

                  /* make sure the rank has all the data. always check each table which is why the funct is first
                   * and it can't be a single line. Capture is already deleted above.
                   * already validated Break and Sever above. */
                  partialRank = requireTable(monsterName, rank, 'General', 'Kill') || partialRank;
                  partialRank = requireTable(monsterName, rank, 'General', 'Hunt') || partialRank;

                  if(!noInvestigations.includes(monsterName))
                  {
                     partialRank = requireTable(monsterName, rank, 'Investigation', 'Bronze') || partialRank;
                     partialRank = requireTable(monsterName, rank, 'Investigation', 'Silver') || partialRank;
                     partialRank = requireTable(monsterName, rank, 'Investigation', 'Gold') || partialRank;

                     //Purple doesn't exist for LR but required for HR/MR
                     if('Low Rank' !== rank)
                        partialRank = requireTable(monsterName, rank, 'Investigation', 'Purple') || partialRank;
                  }
               }
            });

            //partial data shouldn't trigger this validation
            if(!partialRank)
            {
               if(monsterData[monsterName]['Low Rank'])
               {
                  if(monsterData[monsterName]['High Rank'])
                  {
                     //partsPerRank is a set: every value is true. so doing Object.keys excludes no data but is less for JSON
                     if(JSON.stringify(Object.keys(partsPerRank['Low Rank'])) !==
                        JSON.stringify(Object.keys(partsPerRank['High Rank'])))
                        console.error(`Assumption violation: ${monsterName} has different part breaks at low/high rank`);
                     validateSever(monsterName, 'Low Rank', 'High Rank');
                  }
                  else console.error(`Assumption violation: ${monsterName} can be fought at low rank but not high rank`);

                  if(monsterData[monsterName]['Master Rank'])
                  {
                     if(JSON.stringify(Object.keys(partsPerRank['Low Rank'])) !==
                        JSON.stringify(Object.keys(partsPerRank['Master Rank'])))
                        console.error(`Assumption violation: ${monsterName} has different part breaks at low/master rank`);
                     validateSever(monsterName, 'Low Rank', 'Master Rank');
                  }
                  else console.error(`Assumption violation: ${monsterName} can be fought at low rank but not master rank`);
               }
               if(monsterData[monsterName]['High Rank'])
               {
                  if(monsterData[monsterName]['Master Rank'])
                  {
                     if(JSON.stringify(Object.keys(partsPerRank['High Rank'])) !==
                        JSON.stringify(Object.keys(partsPerRank['Master Rank'])))
                        console.error(`Assumption violation: ${monsterName} has different part breaks at high/master rank`);
                     validateSever(monsterName, 'High Rank', 'Master Rank');
                  }
                  //these are event only and that event is only HR
                  else if(!['Ancient Leshen', 'Leshen'].includes(monsterName))
                     console.error(`Assumption violation: ${monsterName} can be fought at high rank but not master rank`);
               }
            }

            const allMaterialNames = Object.keys(materialForMonster);
            allMaterialNames.sort();
            monsterData[monsterName].material = allMaterialNames;

            console.log(monsterName + ' is done');
         });
      }

      function markBadData(message, monsterName)
      {
         if(!badData[message]) badData[message] = [];
         //multiple offenses of the same type are ignored
         if(!badData[message].includes(monsterName)) badData[message].push(monsterName);
         if(!badData.monsters.includes(monsterName)) badData.monsters.push(monsterName);
      }

      function validateSever(monsterName, rank1, rank2)
      {
         //!! converts them to boolean, !== is xor
         const oneMissing = !!monsterData[monsterName][rank1].Sever !== !!monsterData[monsterName][rank2].Sever;
         /* Truth table:
          * Both missing: !oneMissing => pass
          * One missing: oneMissing => violation
          * Both present: !oneMissing => pass */
         if(oneMissing)
            console.error(`Assumption violation: ${monsterName} has different tail sever at ${rank1}/${rank2}`);
      }

      function hasTable(monsterName, rank, sectionName, tableName)
      {
         const exists = monsterData[monsterName][rank][sectionName][tableName];
         if(!exists) return false;

         const empty = (0 === monsterData[monsterName][rank][sectionName][tableName].length);
         if(!empty) return true;

         //there are no scenarios with empty tables but it's easy to check
         console.error(`Assumption violation: empty table: ${monsterName} ${rank} ${sectionName} > ${tableName}`);

         return false;
      }

      function requireTable(monsterName, rank, sectionName, tableName)
      {
         if(!hasTable(monsterName, rank, sectionName, tableName))
         {
            //these are mark because all 6 tables currently happen
            markBadData(`Missing required new table ${rank} ${sectionName} > ${tableName}`, monsterName);
            delete monsterData[monsterName][rank][sectionName][tableName];
            return true;
         }
         return false;
      }

      function groomMonsterData()
      {
         //Zorah is excluded
         if(70 !== Object.keys(monsterData).length)
            console.error(`Missing large monsters. Current length: `, Object.keys(monsterData).length);
         verifyManualCorrection('wrong breakable part', ['Teostra', 'Kushala Daora']);
         verifyManualCorrection('wrong material', ['Safi\'jiiva']);
         verifyManualCorrection('wrong Investigation', noInvestigations);
         verifyManualCorrection('no rewards at Low Rank', ['Nergigante']);

         //TODO: sort monsterData by making a new object that has keys in alpha order
      }

      function verifyManualCorrection(manualCorrectionName, expectedValue)
      {
         const badDataName = 'Manual Correction: ' + manualCorrectionName;
         if(JSON.stringify(expectedValue) !== JSON.stringify(badData[badDataName]))
         {
            console.error(`Need to update: ${badDataName}. Current value: `, badData[badDataName]);
         }
      }

      function makeMaterialAutoComplete()
      {
         const monsterName = document.getElementById('monster').value.trim();

         //clearing breaks and auto complete is only actually needed if Zorah or no data
         document.getElementById('breakingSection').innerHTML = '';
         const materialInput = $('#material');
         materialInput.autocomplete({source: []});

         if(!validateMonsterName(monsterName)) return;

         /* if old material name isn't valid then replace it with the most common material.
          * Rath Wingtalon exists for Low Rank Rathian and Rathalos so it is possible to stay but rare.
          * I didn't want to replace it with the first material because that's typically
          * Ancient Feystone which isn't monster specific (it's Purple investigation). */
         if(!monsterData[monsterName].material.includes(document.getElementById('material').value.trim()))
         {
            /* [0] will be the one with the highest %
             * Have to check each rank because some monsters aren't at every rank
             * But I want the lowest available rank */
            document.getElementById('material').value = findLowestRankTable(monsterName, 'General', 'Kill')[0].material;
         }

         materialInput.autocomplete({
            source: monsterData[monsterName].material
         });

         let breakingSectionHtml = '';
         Object.keys(findHighestRankBreakSection(monsterName)).forEach(partName =>
         {
            //TODO: have break and investigation display x1 25% but only possible after rank based auto complete
            //break doesn't work until then for silver rathalos. or until I beat HR and exclude his HR

            //this handles some tail (break)
            breakingSectionHtml += `<label>Break ${partName}: <input type="checkbox" checked="checked" value="${partName}" /></label><br />`;
         });
         if(findLowestRankTable(monsterName, 'Sever', 'tail'))
         {
            breakingSectionHtml += '<label>Sever and carve tail: <input type="checkbox" checked="checked" ' +
               'id="sever-tail" value="tail" /></label><br />';
         }

         //not valid. this is to support partial data
         if('' === breakingSectionHtml)
            breakingSectionHtml = 'Part breaking info not found';

         document.getElementById('breakingSection').innerHTML = breakingSectionHtml;
      }

      /**
       * @returns {boolean} true if valid
       */
      function validateMonsterName(monsterName)
      {
         if('Zorah Magdaros' === monsterName)
         {
            alert('Zorah Magdaros isn\'t currently supported (see reason below).');
            /* If you aren't master rank and have no investigations then the calc would "just work"
             * but I don't want that validation, the data is questionable, and no one will mind this being excluded. */
            return false;
         }
         if(!monsterData[monsterName])
         {
            alert(`No data for monster named "${monsterName}". Check your spelling and try again.`);
            return false;
         }
         return true;
      }

      /** @returns {Array} table. not found will throw */
      function findLowestRankTable(monsterName, section, table)
      {
         //if the rank exists then all sections (except sever) will exist
         const lowestRank = ['Low Rank', 'High Rank', 'Master Rank'].find(rank =>
            monsterData[monsterName][rank] && monsterData[monsterName][rank][section] && monsterData[monsterName][rank][section][table]);
         if(lowestRank) return monsterData[monsterName][lowestRank][section][table];

         //must stop because it would cause NPE
         alert(`Assumption violation: no table for any rank: ${monsterName} ${section} > ${table}`);
         throw new Error(`Assumption violation: no table for any rank: ${monsterName} ${section} > ${table}`);
      }

      /** @returns {object} Break object. not found returns {} */
      function findHighestRankBreakSection(monsterName)
      {
         //check highest first since all monsters should have MR
         //const highestRank = ['Master Rank', 'High Rank', 'Low Rank'].find(rank =>
         const highestRank = ['High Rank', 'Low Rank'].find(rank =>
            monsterData[monsterName][rank] && 0 !== Object.keys(monsterData[monsterName][rank].Break).length);
         if(highestRank) return monsterData[monsterName][highestRank].Break;

         return {};
      }

      function readForm()
      {
         const monsterName = document.getElementById('monster').value.trim();
         const material = document.getElementById('material').value.trim();
         const rank = document.getElementById('huntRank').value;

         if(!validateMonsterName(monsterName)) return;

         if('Nergigante' === monsterName && 'Low Rank' === rank)
         {
            alert(`Nergigante has no Low Rank rewards`);
            return;
         }
         if(!monsterData[monsterName][rank])
         {
            alert(`${monsterName} can't be fought at ${rank}`);
            return;
         }
         //else assume they can be fought and just calc partial data

         const dataToCrunch = [];
         //this table is too hard to make DRY with above since this uses the form
         const tablesToSearch = [
            {section: 'General', table: 'Kill', rewardCount: 4},
            {section: 'General', table: 'Hunt', rewardCount: 4},
            //quest table added below
            {
               section: 'Investigation',
               table: 'Bronze',
               rewardCount: Number.parseInt(document.getElementById('bronzeReward').value)
            },
            {
               section: 'Investigation',
               table: 'Silver',
               rewardCount: Number.parseInt(document.getElementById('silverReward').value)
            },
            {
               section: 'Investigation',
               table: 'Gold',
               rewardCount: Number.parseInt(document.getElementById('goldReward').value)
            },
            {
               section: 'Investigation',
               table: 'Purple',
               rewardCount: Number.parseInt(document.getElementById('purpleReward').value)
            }
         ];

         document.querySelectorAll('input[type="checkbox"]').forEach(checkElement =>
         {
            if(checkElement.checked && 'sever-tail' !== checkElement.id)
            {
               //this handles break tail as well
               tablesToSearch.push({
                  section: 'Break',
                  table: checkElement.value,
                  rewardCount: 1
               });
            }
         });
         if(document.getElementById('sever-tail') && document.getElementById('sever-tail').checked)
         {
            tablesToSearch.push({
               section: 'Sever',
               table: 'tail',
               rewardCount: 1
            });
         }

         tablesToSearch.forEach(tableStructure =>
         {
            //Investigations can be 0. table is only missing for the Leshens and partial data
            if(0 !== tableStructure.rewardCount && monsterData[monsterName][rank][tableStructure.section][tableStructure.table])
            {
               const materialData = monsterData[monsterName][rank][tableStructure.section][tableStructure.table]
               .find(monsterTable => material === monsterTable.material);
               if(materialData) dataToCrunch.push({
                  tableCount: tableStructure.rewardCount,
                  itemCount: materialData.itemCount,
                  probability: materialData.probability
               });
            }
         });

         const questItemCount = Number.parseInt(document.getElementById('questItemCount').value);
         const questPercent = Number.parseInt(document.getElementById('questPercent').value);
         if(0 !== questItemCount && 0 !== questPercent)
         {
            dataToCrunch.push({tableCount: 3, itemCount: questItemCount, probability: questPercent / 100});
         }

         if(0 === dataToCrunch.length)
         {
            alert(`"${material}" can't be obtained from ${monsterName} at ${rank} with this form data.`);
            return;
         }

         crunchData(dataToCrunch, Number.parseInt(document.getElementById('huntCount').value));
      }

      //TODO: verify results via simulation (input small numbers) and write unit tests
      function crunchData(data, completeCount)
      {
         if(0 === data.length) alert('No data');  //unreachable through form
         const eachTable = [];
         for(let tableIndex = 0; tableIndex < data.length; ++tableIndex)
         {
            const thisTable = Combination.binomialDistribution(data[tableIndex].tableCount, data[tableIndex].probability);
            for(let outcomeIndex = 0; outcomeIndex < thisTable.length; ++outcomeIndex)
            {
               //convert number of times got reward to number of items
               thisTable[outcomeIndex].result *= data[tableIndex].itemCount;
            }
            eachTable.push(thisTable);
         }

         const everyHuntOutcome = calcEveryHuntOutcome(eachTable);
         let finalResults = everyHuntOutcome;
         if(1 !== completeCount)
         {
            const huntCartesianHolder = [];
            for(let completeIndex = 1; completeIndex <= completeCount; ++completeIndex)
            {
               huntCartesianHolder.push(everyHuntOutcome.copy());
            }
            finalResults = calcEveryHuntOutcome(huntCartesianHolder);
         }

         let out = '<b>Monster material</b> ';
         const aggregate = Statistics.calculateAggregates(finalResults);
         out += GenerateHtml.aggregates(aggregate);
         out += GenerateHtml.statistics(finalResults, '>='); //default col
         out = out.replace('<th>Roll</th>', '<th>Count</th>');  //easier to just edit than some new arg etc
         document.getElementById('graphResults').innerHTML = out;

         function calcEveryHuntOutcome(eachTable)
         {
            if(1 === eachTable.length) return eachTable[0];  //if there's only 1 table then this already is every outcome
            /*
             * eachTable[0].length ^ eachTable.length == huntCartesianProduct.length
             * magic number based on testing
             * max: Math.log(16777216) / Math.log(eachTable[0].length)
             * however 5 completeCount won't hit this and 5+ is unrealistic
             */
            const huntCartesianProduct = Combination.cartesianProduct(eachTable);
            const everyHuntOutcomeObj = {};
            for(let productIndex = 0; productIndex < huntCartesianProduct.length; ++productIndex)
            {
               let thisResult = 0;
               let thisProbability = 1;
               for(let resultIndex = 0; resultIndex < huntCartesianProduct[productIndex].length; ++resultIndex)
               {
                  thisResult += huntCartesianProduct[productIndex][resultIndex].result;
                  thisProbability *= huntCartesianProduct[productIndex][resultIndex].probability;
               }
               if(everyHuntOutcomeObj[thisResult] === undefined) everyHuntOutcomeObj[thisResult] = 0;
               everyHuntOutcomeObj[thisResult] += thisProbability;
            }
            const everyHuntOutcome = [];
            for(let resultProp in everyHuntOutcomeObj)
            {
               if(everyHuntOutcomeObj.hasOwnProperty(resultProp))
               {
                  everyHuntOutcome.push({result: Number.parseInt(resultProp), probability: everyHuntOutcomeObj[resultProp]});
               }
            }
            return everyHuntOutcome;
         }
      }
   </script>
</head>
<body>
<form action="javascript:readForm();" onchange="document.getElementById('graphResults').innerHTML = ''">
   <br />
   <label>Monster to hunt:<input type="text" id="monster" value="Rathalos" onchange="makeMaterialAutoComplete()" /></label>
   <label>Material:<input type="text" id="material" value="Rathalos Scale" /></label><br />

   <label>Rank: <select id="huntRank">
      <option>Low Rank</option>
      <option>High Rank</option>
      <option>Master Rank</option>
   </select></label><br />

   <h2>Breaking parts</h2>
   <div id="breakingSection"></div>

   <h2><span title="Quest Rewards" class="hoverInfo">Quest</span></h2>
   <label>Material per reward slot <input type="number" min="1" value="1" max="5" id="questItemCount" /></label>
   <label>Chance <input type="number" min="0" max="100" value="0" id="questPercent" />%</label><br />

   <h2>Investigation reward slots</h2>
   <table>
      <tbody>
      <tr>
         <th><label for="bronzeReward" style="color: #993D00">Bronze</label></th>
         <th><label for="silverReward">Silver</label></th>
         <th><label for="goldReward" style="color: #E6E600">Gold</label></th>
         <th><label for="purpleReward" style="color: #8000FF">Purple</label></th>
      </tr>
      <tr>
         <td><input type="number" min="0" max="5" value="0" id="bronzeReward" /></td>
         <td><input type="number" min="0" max="5" value="0" id="silverReward" /></td>
         <td><input type="number" min="0" max="5" value="0" id="goldReward" /></td>
         <td><input type="number" min="0" max="5" value="0" id="purpleReward" /></td>
      </tr>
      </tbody>
   </table>
   <br />

   <label>Number of times you do will this hunt: <input type="number" min="1" value="1" max="5" id="huntCount" /></label><br />

   <input type="submit" value="Calculate" />
</form>
<br />
<div id="graphResults"></div>
<p>If you need a specific rare material in Monster Hunter World then input the stats of hunting a single monster and this will output the
   probability of each possible number of material you'll get.
   This programs calculates as much as possible and is pessimistic about the rest so that your actual odds should be better than reported.
   This scrapes data from <a href="https://mhworld.kiranico.com/">https://mhworld.kiranico.com/</a>.
   Text with red underline will show the name of the table from <a href="https://mhworld.kiranico.com/">kiranico</a> when you hover over it.
   First of all some terminology: a reward slot is a single square on the results page after a hunt. Each reward slot generally has 1
   material but it can have more than 1.</p>
<p><span title="Carves: Carves" class="hoverInfo">Carve</span> and <span title="Rewards: Capture" class="hoverInfo">Capture</span> are
   always identical tables the only difference is that you can always carve a dead monster 4 times, each of which puts in your box
   the equivalent of a reward slot (it won't be on the results page), but capturing will give 4 or 5 reward slots.
   However since I don't know the criteria/formula for when you would get 5 this calculator assumes you get 4 and
   thus they are completely identical which is why there's no input to indicate if the monster was captured.
   <span title="Rewards: Hunt" class="hoverInfo">Hunt</span> you get whether you kill or capture and is 4-8 reward slots however I once
   again don't know the criteria/formula so this assumes 4. An expedition would give 3-4 reward slots from the
   <span title="Rewards: Hunt" class="hoverInfo">Hunt</span> table but this calculator assumes you aren't doing an expedition.
   <span title="Carves: Carves" class="hoverInfo">Carve</span>/<span title="Rewards: Capture" class="hoverInfo">Capture</span> and
   <span title="Rewards: Hunt" class="hoverInfo">Hunt</span> are based on the large monster (I don't know how expeditions or multiple large
   monsters are calculated) and those tables are scraped from the large monster's page
   (and thus are covered by the name and material inputs).
   <span title="Quest Rewards" class="hoverInfo">Quest</span> is specific to the quest taken and this info can be found on
   <a href="https://mhworld.kiranico.com/quests">kiranico</a> as well.
   <span title="Quest Rewards" class="hoverInfo">Quest</span> will give 4-8 reward slots but the first
   <span title="Quest Rewards" class="hoverInfo">Quest</span> reward slot is always 100%
   (and thus doesn't need to be calculated) thus this calculator assumes 3.
   You may input the info for <span title="Quest Rewards" class="hoverInfo">Quest</span> above however it's unlikely to have the desired
   material.
   Investigations do in fact have <span title="Quest Rewards" class="hoverInfo">Quest</span>
   rewards which can be found <a href="https://game8.co/games/Monster-Hunter-World/archives/306257#hm_4">here</a>.
   You'll notice that (beside the 100%) they don't have percentages listed but this is the only place I could find the info.</p>
<p>After a hunt the "Quest completion rewards" will have the rewards from both <span title="Rewards: Hunt" class="hoverInfo">Hunt</span>
   and <span title="Quest Rewards" class="hoverInfo">Quest</span> the only way to tell them apart is that the
   <span title="Rewards: Hunt" class="hoverInfo">Hunt</span>
   rewards are first then the 100% <span title="Quest Rewards" class="hoverInfo">Quest</span> reward then the rest of the
   <span title="Quest Rewards" class="hoverInfo">Quest</span> rewards. The "Quest completion rewards" can hold a
   maximum of 20 reward slots (each might have multiple copies of the material) which is enough room for the max 16 slots for single
   monster hunts. The box below it "Bonus rewards" has 20 slots for materials from breaking monster parts then for Capture rewards (they
   will be labeled). After that are the Investigation slots (max of 5?) then the 20 Palico slots and 20 Tailraider slots
   (10 gathered and 10 stolen each).</p>
<p>Some monster breaks involve multiple body parts, such as having 2 wings. In that case each wing has it's own HP but both wings
   need to be broken to receive the reward slot for the break (for "Break Rathalos's wings") therefore you can only get 1 reward slot
   per break table per monster. This
   is why the input for breaking is a checkbox instead of asking how many times. There is a partial exception for
   <a href="https://mhworld.kiranico.com/monsters/aYaUV/nergigante">Nergigante</a> and
   <a href="https://mhworld.kiranico.com/monsters/oAnim/ruiner-nergigante">Ruiner Nergigante</a> who have "break horn" and "break horns"
   as separate tables for breaking 1 horn then both horns.
   <a href="https://mhworld.kiranico.com/monsters/oAnim/ruiner-nergigante">Ruiner Nergigante</a>
   also has separate tables for each front leg and each wing these cases are covered by having separate checkboxes
   (in this case 8 of them).</p>
<p><a href="https://mhworld.kiranico.com/">Kiranico</a> also has info on Tailraider Safari, Bandit Mantle, Plunderblade,
   Items Gathered by Palicoes, materials from Monster tracks, Dropped Material, Guiding lands, and basically everything you can think of.
   The Dropped Material table is
   what a monster may drop when they are toppled or have their body parts broken (the white items you have to pick up), which is not
   to be confused with the tables for "Break Rathalos's head" etc which are Bonus rewards for breaking monster parts at the end
   of a hunt. The calculator doesn't account for any of these except breaking and you should break as many parts are you can.</p>
<p><a href="https://mhworld.kiranico.com/monsters/EmVcV/zorah-magdaros">Zorah Magdaros</a> is excluded for now because the page's data
   is invalid: Carves master rank is missing, I don't know if it's ever possible to carve his corpse (so Carves: Carves should be N/A),
   Carves: Dropped Material is obviously impossible (you can break parts but not run to his feet to get a white material drop),
   Carves: Bandit Mantle is wrong since it lists non trade-in items, Carves: Plunderblade is impossible since your Palico won't help with
   the magma cores, Carves: Items Gathered by Palicoes is wrong since it lists a Bandit Mantle material, master rank of Rewards and
   Investigations are obviously wrong, Rewards: Capture Zorah Magdaros is probably impossible (ref:
   <a href="https://mhworld.kiranico.com/quests/nXmB6/one-for-the-history-books">★4 One for the History Books</a>),
   and Investigations doesn't apply to him at all (I think). Rewards: Break Zorah Magdaros's head, Rewards: Break Zorah Magdaros's chest,
   and Rewards: Hunt Zorah Magdaros might be valid but it breaks too many assumptions for this calculator to handle. In the future I might
   add special logic for handling Zorah Magdaros.</p>
<p>It turns out that all 71 (including Zorah Magdaros) large monster pages have something about the data incorrect. The calculations
   will run on partial data in order to give the best results possible.
   TODO: list the general corrections once I have them all</p>
<p>Personal experience and rumors: I had all 20 "Quest completion rewards" filled in
   <a href="https://mhworld.kiranico.com/quests/naKbA/redefining-the-power-couple">★5 Redefining the "Power Couple"</a> since it's a 2
   monster quest it makes me think I was cheated out of the 4 possible remaining reward slots.
   Supposedly a Lucky Voucher will guarantee the max of 8 <span title="Quest Rewards" class="hoverInfo">Quest</span>
   rewards, I can't disprove that since
   I always get 8 when I have 0 faints and I usually don't faint. It is possible that the Lucky Voucher's description of
   "to add bonus rewards" is only talking about doubling the money (and thus doesn't affect what I call "reward slots" at all).
   Poogie does not affect the hunt at all (reward slots, material count, cash, or research points). Deal with it.
   Although if Poogie likes you (any amount) then you can use him to find treasure which are materials that could be sold.</p>
<p>The armor skills Good Luck and Great Luck and the food skill Lucky Cat supposedly have a chance to increase the number of materials
   (0-5 more) in a given reward slot but not
   the number of reward slots used and thus don't affect the chances of getting "at least 1" of the material desired. It would
   be very tedious to verify those skills since it would require doing a ton of hunts with the skill and comparing to the expected number
   of each material. Armor skill Capture Master does the same thing but only if the monster is captured. The food skill Felyne Carver (Hi)
   on the other hand increases the number of times you can carve which would make
   <span title="Carves: Carves" class="hoverInfo">Carve</span> be 4-5 reward slots making it the same as the 4-5 normally gotten from
   capturing a monster. The details of all of these are unknown and thus not included but (unlike Poogie) aren't superstitious
   so it is a good idea to have them.</p>
<br /><br /><br /><br />
<script>
   'use strict';
   document.getElementById('monster').focus();

   const allMonsterNames = Object.keys(monsterData);
   //Zorah Magdaros has no data but is in the list so that people can see the alert message (since they won't RTFM)
   allMonsterNames.push('Zorah Magdaros');
   allMonsterNames.sort();
   $('#monster').autocomplete({
      source: allMonsterNames
   });
   //autocomplete default monster (in case it doesn't on change)
   makeMaterialAutoComplete();
</script>
</body>
</html>
