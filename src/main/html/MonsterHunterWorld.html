<!DOCTYPE HTML>
<html>
<head>
   <meta charset="UTF-8" />
   <title>Material Hunt Stats - MHW</title>
   <script id="DiceInclude" src="../javascript/Include.js"></script>
   <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.0/themes/base/jquery-ui.css" />
   <style>
      /*Style based on the H&H css but with red hover and blue links*/

      /*classes autocomplete etc are from jquery-ui*/
      html, body, input, textarea, select, button,
      .ui-autocomplete .ui-menu-item .ui-menu-item-wrapper {
         background-color: black;
         border-color: #202020;
         color: #A0A0A0;
      }

      .ui-autocomplete .ui-menu-item .ui-menu-item-wrapper.ui-state-active {
         background-color: #000040;
      }

      ::-webkit-scrollbar {
         background-color: #101010;
      }

      ::-webkit-scrollbar-thumb {
         background-color: #202020;
      }

      a:link, a:visited {
         color: #79AAFF;
      }

      p {
         max-width: 1000px;
      }

      h2 {
         font-size: 28px;
      }

      .hoverInfo {
         color: red;
         border-bottom: 1px dotted red;
      }
   </style>
   <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4="
           crossorigin="anonymous"></script>
   <script src="https://code.jquery.com/ui/1.13.0/jquery-ui.min.js" integrity="sha256-hlKLmzaRlE8SCJC1Kw8zoUbU8BxA+8kR3gseuKfMjxA="
           crossorigin="anonymous"></script>
   <script>
      'use strict';

      /**This disables jquery from requesting images when parsing html*/
      const virtualDocument = document.implementation.createHTMLDocument('virtual');
      const monstersNameToLink = {};
      /* Data validations:
       * 1 The only way to break a tail is to sever and carve it
       * 2 Only a tail can be severed
       * 3 Rewards: Capture is same as Carves: Carves
       * 4 each table adds up to 100% (won't affect calculations but would be good to verify non bad data)
       * 5 LR monsters will have HR and MR fights
       * 6 HR monsters will have MR fights
       * 7 if a monster can be fought at rank then it must have all tables I look for except tail/breaks
       * 8 There will not be duplicate tables
       * 9 there will not be duplicate material of same count in a table. ask data if there's any of diff counts
       * 10 monsters have the same breakable parts at every rank
       *
       * Data corrections:
       * 1 the duplicate MR Capture tables are for guiding lands low, mid, high, and tempered. they are ignored
       * 2 Ruiner Nergigante ignored HR purple
       * 3 Nergigante ignored LR and MR (also MR carve was missing)
       *
       * Assumptions (don't affect calc):
       * 1 Bandit Mantle only gives trade-in items (pretty sure the game says this)
       * 2 some monsters are not in low rank (I know this 1)
       * 3 some monsters are not in high rank (probably but not sure). will ask data when complete
       * 4 master rank can fight everything and high can fight all low
       * */
      //TODO: store data offline (more legit) then validate it and correct Zorah
      //TODO: first move these into pure functions with promise?
      //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all
      /* keep the parser so I can update it as needed (mark last date used) but might be too slow to loop all (chrome would kill?)
       * so if that fails I'll have to break it up somehow. there's 71 monsters (including Zorah). */
      let monsterData = {};

      function makeMonsterAutoComplete()
      {
         document.getElementById('monster').style.visibility = "hidden";
         document.getElementById('promisePlaceholder').style.visibility = "visible";
         $.get('https://mhworld.kiranico.com/monsters').fail(() =>
         {
            alert('Failed to load https://mhworld.kiranico.com/monsters (the monster index).\nConnect to internet and refresh this page.');
         })
         .done(function(html)
         {
            $(html, virtualDocument).find('h6:contains("Large Monsters")+div>div>table a').each((index, element) =>
            {
               monstersNameToLink[element.textContent] = element.href;
            });
            const allMonsterNames = Object.keys(monstersNameToLink);
            //monster names are already sorted but good to enforce that
            allMonsterNames.sort();
            //Zorah Magdaros isn't removed from list so that people can see the alert message (see below)
            $('#monster').autocomplete({
               source: allMonsterNames
            });
            document.getElementById('monster').style.visibility = "visible";

            //populate material on page load in case the monster doesn't change
            makeMaterialAutoComplete();
         });
      }

      function makeMaterialAutoComplete()
      {
         const monsterName = document.getElementById('monster').value.trim();
         const monsterUrl = monstersNameToLink[monsterName];

         document.getElementById('material').style.visibility = "hidden";
         document.getElementById('breakingSection').innerHTML = '';

         if('Zorah Magdaros' === monsterName)
         {
            alert("Zorah Magdaros isn't currently supported (see reason below).");
            /* If you aren't master rank and have no investigations then the calc would "just work"
             * but I don't want that validation, the data is questionable, and no one will mind this being excluded. */
            return;  //makeMaterialAutoComplete
         }
         if(!monsterUrl)
         {
            alert(`No data for monster named "${monsterName}". Check your spelling and try again.`);
            return;  //makeMaterialAutoComplete
         }

         document.getElementById('promisePlaceholder').style.visibility = "visible";
         //can't cache results because .done needs to set some DOM
         $.get(monsterUrl).fail(() =>
         {
            alert('Failed to load ' + monsterUrl);
         })
         .done(function(html)
         {
            /*Example:
               {
                  General: {Kill: [], Capture: [], Hunt: []},
                  Break: {tail: [], horn: [], horns: []},
                  Investigation: {Bronze: [], Silver: [], Gold: [], Purple: []}
               }
               each one has {material: 'M Scale', itemCount: 1, probability: 0.05}
               Investigation.Purple won't be created for LR
               Break is populated only by parts found (including tail)
            */
            monsterData[monsterName] =
               {
                  "Low Rank": {General: {}, Break: {}, Investigation: {}},
                  "High Rank": {General: {}, Break: {}, Investigation: {}},
                  "Master Rank": {General: {}, Break: {}, Investigation: {}}
               };
            const materialForMonster = {};
            const allParts = {};
            //partsPerRank is for validation
            const partsPerRank = {
               "Low Rank": {},
               "High Rank": {},
               "Master Rank": {}
            };
            //tail is tracked separate because it has a different label
            let canCarveTail = false;
            const hasRank = {};

            const sectionsToKeep =
               {
                  'Carves': ['Carves', 'Tail Carved'],
                  //Carves: Carves is same as Rewards: Capture include both for validation
                  'Rewards': [`Capture ${monsterName}`, `Hunt ${monsterName}`],
                  //quest table not from this page
                  'Investigations':
                     [
                        'Investigation Reward (Bronze)',
                        'Investigation Reward (Silver)',
                        'Investigation Reward (Gold)',
                        'Investigation Reward (Purple)'
                     ]
               };
            const oldToNewStructure =
               {
                  'Carves': {'Carves': {section: 'General', table: 'Kill'}, 'Tail Carved': {section: 'Break', table: 'tail'}},
                  //Carves: Carves is same as Rewards: Capture include both for validation
                  'Rewards': {
                     [`Capture ${monsterName}`]: {section: 'General', table: 'Capture'},
                     [`Hunt ${monsterName}`]: {section: 'General', table: 'Hunt'}
                  },
                  //quest table not from this page
                  'Investigations':
                     {
                        'Investigation Reward (Bronze)': {section: 'Investigation', table: 'Bronze'},
                        'Investigation Reward (Silver)': {section: 'Investigation', table: 'Silver'},
                        'Investigation Reward (Gold)': {section: 'Investigation', table: 'Gold'},
                        'Investigation Reward (Purple)': {section: 'Investigation', table: 'Purple'}
                     }
               };

            $(html, virtualDocument).find('h6').each((index, sectionSearch) =>
            {
               const sectionText = sectionSearch.textContent;
               const tablesToKeep = sectionsToKeep[sectionText];
               //if not a section to keep then continue
               if(!tablesToKeep) return;  //html looping sectionSearch

               const section = sectionSearch.nextElementSibling;
               $(section, virtualDocument).find('h6').each((index, rankSearch) =>
               {
                  const rankText = rankSearch.textContent;
                  if(('Ruiner Nergigante' === monsterName && 'Master Rank' !== rankText) ||
                     ('Nergigante' === monsterName && 'High Rank' !== rankText))
                  {
                     //ignore some bad data
                     delete monsterData[monsterName][rankText];
                     //hasRank won't be used
                     return;  //section looping rankSearch
                  }
                  if(!rankSearch.nextElementSibling)
                  {
                     //don't trigger if hasRank[rankText] is undefined since that would be first pass
                     if(true === hasRank[rankText])
                     {
                        //the data is unacceptable because it would cause NPE
                        alert(`Assumption violation: ${monsterName} has unacceptable bad data: partial data for ${rankText}`);
                        //throw in order to stop makeMaterialAutoComplete instead of just the rank
                        throw new Error(`${monsterName} has unacceptable bad data: partial data for ${rankText}`);
                     }

                     /* all pages have the 3 rank cols but some are empty (can't be fought at that rank)
                      * in which case delete the empty objects and continue */
                     delete monsterData[monsterName][rankText];
                     hasRank[rankText] = false;
                     return;  //section looping rankSearch
                  }
                  //don't trigger if hasRank[rankText] is undefined since that would be first pass
                  if(false === hasRank[rankText])
                  {
                     //the data is unacceptable because it would cause NPE
                     alert(`Assumption violation: ${monsterName} has unacceptable bad data: partial data for ${rankText}`);
                     //throw in order to stop makeMaterialAutoComplete instead of just the rank
                     throw new Error(`${monsterName} has unacceptable bad data: partial data for ${rankText}`);
                  }
                  hasRank[rankText] = true;

                  const rankCol = rankSearch.parentElement;
                  //the table name is actually a td and not th
                  $(rankCol, virtualDocument).find('td').each((index, tableSearch) =>
                  {
                     const tableText = tableSearch.textContent.trim();
                     let thisPartName = undefined;
                     //I suppose I could hard code all possible part names but startsWith works fine
                     if(tableText.startsWith('Break ' + monsterName + '\'s '))
                     {
                        //should already be lowercase but enforce it
                        thisPartName = tableText.substring(('Break ' + monsterName + '\'s ').length).toLowerCase();
                        if('tail' === thisPartName) console.error(`Assumption violation: ${monsterName} has a broken tail`);
                        allParts[thisPartName] = true;
                        partsPerRank[rankText][thisPartName] = true;
                     }
                     else if('Tail Carved' === tableText) canCarveTail = true;
                     else if(tableText.contains(' Carved'))
                     {
                        console.error(`Assumption violation: can sever non tail of ${monsterName}`);
                        return;  //rankCol looping tableSearch
                     }
                     //if not a table to keep then continue
                     else if(!tablesToKeep.includes(tableText)) return;
                     //there's a guiding lands bug in MR: they are instead labeled "Capture X" so ignore all but first capture
                     else if('Capture ' + monsterName === tableText &&
                        undefined !== monsterData[monsterName][rankText].General.Capture)
                        return;  //rankCol looping tableSearch

                     // td > tr > tbody > table
                     const table = tableSearch.parentElement.parentElement.parentElement;

                     let percentSum = 0;
                     let dataLocation = undefined;
                     const newStructure = oldToNewStructure[sectionText][tableText];
                     if(newStructure)
                     {
                        //tail is handled here
                        if(monsterData[monsterName][rankText][newStructure.section][newStructure.table])
                           console.error(`Assumption violation: ${monsterName} ${rankText} ` +
                              `${sectionText} > ${tableText} duplicate table`);

                        dataLocation = monsterData[monsterName][rankText][newStructure.section][newStructure.table] = [];
                     }
                     else if(thisPartName)
                     {
                        if(monsterData[monsterName][rankText]['Break'][thisPartName])
                           console.error(`Assumption violation: ${monsterName} ${rankText} ` +
                              `${sectionText} > ${tableText} duplicate table`);

                        dataLocation = monsterData[monsterName][rankText]['Break'][thisPartName] = [];
                     }
                     else
                     {
                        //must stop because it would cause NPE
                        alert(`Programming bug: unmapped table: ${monsterName} ${rankText} ${sectionText} > ${tableText}`);
                        //throw in order to stop makeMaterialAutoComplete instead of just the table
                        throw new Error(`Programming bug: unmapped table: ${monsterName} ${rankText} ${sectionText} > ${tableText}`);
                     }

                     const materialInTable = {};
                     $(table, virtualDocument).find('span').each((index, materialSearch) =>
                     {
                        const material = materialSearch.textContent;
                        materialForMonster[material] = true;
                        const materialLink = materialSearch.parentElement;
                        let materialCount = 1;
                        if(null !== materialLink.nextSibling && 0 !== materialLink.nextSibling.textContent.trim().length)
                        {
                           materialCount = Number.parseInt(materialLink.nextSibling.textContent.replace(' x', ''));
                        }
                        const materialPercentElement = materialLink.parentElement.nextElementSibling.textContent;
                        const materialPercentNumber = Number.parseInt(materialPercentElement.replace('%', ''));
                        percentSum += materialPercentNumber;
                        const materialProbability = materialPercentNumber / 100;

                        //material can be in table more than once if it has different counts
                        if(materialCount === materialInTable[material])
                           console.error(`Assumption violation: ${monsterName} ${rankText} ` +
                              `${sectionText} > ${tableText} duplicate material: ${material} x${materialCount}`);
                        materialInTable[material] = materialCount;

                        dataLocation.push({
                           material: material,
                           itemCount: materialCount,
                           probability: materialProbability
                        });
                     });

                     if(100 !== percentSum)
                        console.error(`Assumption violation: ${monsterName} ${rankText} ` +
                           `${sectionText} > ${tableText} doesn't add up to 100%`);
                  });
               });
            });

            //have to wait for entire data because these are in different sections
            ["Low Rank", "High Rank", "Master Rank"].forEach(it =>
            {
               //if monster has this rank but these 2 tables are different
               if(monsterData[monsterName][it] &&
                  JSON.stringify(monsterData[monsterName][it].General.Kill) !==
                  JSON.stringify(monsterData[monsterName][it].General.Capture))
                  console.error(`Assumption violation: ${monsterName} carve/capture doesn't match for ${it}`);
            });

            if(monsterData[monsterName]['Low Rank'])
            {
               if(!monsterData[monsterName]['High Rank'])
                  console.error(`Assumption violation: ${monsterName} can be fought at low rank but not high rank`);
               else if(JSON.stringify(Object.keys(partsPerRank['Low Rank'])) !==
                  JSON.stringify(Object.keys(partsPerRank['High Rank'])))
                  console.error(`Assumption violation: ${monsterName} has different part breaks at low/high rank`);
               if(!monsterData[monsterName]['Master Rank'])
                  console.error(`Assumption violation: ${monsterName} can be fought at low rank but not master rank`);
               else if(JSON.stringify(Object.keys(partsPerRank['Low Rank'])) !==
                  JSON.stringify(Object.keys(partsPerRank['Master Rank'])))
                  console.error(`Assumption violation: ${monsterName} has different part breaks at low/master rank`);
            }
            //Nergigante violates assumptions because of partial data so it doesn't count
            if(monsterData[monsterName]['High Rank'] && 'Nergigante' !== monsterName)
            {
               if(!monsterData[monsterName]['Master Rank'])
                  console.error(`Assumption violation: ${monsterName} can be fought at high rank but not master rank`);
               else if(JSON.stringify(Object.keys(partsPerRank['High Rank'])) !==
                  JSON.stringify(Object.keys(partsPerRank['Master Rank'])))
                  console.error(`Assumption violation: ${monsterName} has different part breaks at high/master rank`);
            }

            const allMaterialNames = Object.keys(materialForMonster);
            allMaterialNames.sort();
            $('#material').autocomplete({
               source: allMaterialNames
            });

            /* if old material name isn't valid then replace it with the most common material.
             * Rath Wingtalon exists for Low Rank Rathian and Rathalos so it is possible to stay but rare.
             * I didn't want to replace it with the first material because that's typically
             * Ancient Feystone which isn't monster specific (it's Purple investigation). */
            if(!allMaterialNames.includes(document.getElementById('material').value.trim()))
            {
               let commonMaterial = '';
               /* [0] will be the one with the highest %
                * Have to check each rank because some monsters aren't at every rank
                * But I want the lowest available rank */
               if(monsterData[monsterName]['Low Rank'])
                  commonMaterial = monsterData[monsterName]['Low Rank'].General.Kill[0].material;
               else if(monsterData[monsterName]['High Rank'])
                  commonMaterial = monsterData[monsterName]['High Rank'].General.Kill[0].material;
               else if(monsterData[monsterName]['Master Rank'])
                  commonMaterial = monsterData[monsterName]['Master Rank'].General.Kill[0].material;
               document.getElementById('material').value = commonMaterial;
            }

            let breakingSectionHtml = '';

            Object.keys(allParts).forEach(it =>
            {
               if('tail' === it.toLowerCase()) console.error(`Assumption violation: ${monsterName} has a broken tail`);
               breakingSectionHtml += `<label>Break ${it}: <input type="checkbox" checked="checked" value="${it}" /></label><br />`;
            });

            if(canCarveTail)
               breakingSectionHtml += '<label>Sever and carve tail: <input type="checkbox" checked="checked" ' +
                  'id="break-tail" value="tail" /></label><br />';

            document.getElementById('breakingSection').innerHTML = breakingSectionHtml;

            document.getElementById('material').style.visibility = "visible";
            document.getElementById('promisePlaceholder').style.visibility = "hidden";
         });
      }

      function readForm()
      {
         if('visible' === document.getElementById('promisePlaceholder').style.visibility)
         {
            alert('Keep waiting for internet data.');
            return;
         }

         const monsterName = document.getElementById('monster').value.trim();
         const material = document.getElementById('material').value.trim();
         const rank = document.getElementById('huntRank').value;

         if(!monsterData[monsterName][rank])
         {
            alert(`${monsterName} can't be fought at ${rank}`);
            return;
         }

         const data = [];
         //this table is too hard to make DRY with above since this uses the form
         const tablesToSearch = [
            //General: Kill and Capture are the same
            {section: 'General', table: 'Kill', rewardCount: 4},
            {section: 'General', table: 'Hunt', rewardCount: 4},
            //quest table added below
            {
               section: 'Investigation',
               table: 'Bronze',
               rewardCount: Number.parseInt(document.getElementById('bronzeReward').value)
            },
            {
               section: 'Investigation',
               table: 'Silver',
               rewardCount: Number.parseInt(document.getElementById('silverReward').value)
            },
            {
               section: 'Investigation',
               table: 'Gold',
               rewardCount: Number.parseInt(document.getElementById('goldReward').value)
            },
            {
               section: 'Investigation',
               table: 'Purple',
               rewardCount: Number.parseInt(document.getElementById('purpleReward').value)
            }
         ];

         document.querySelectorAll('input[type="checkbox"]').forEach(it =>
         {
            if(it.checked)
            {
               //this handles tail as well
               tablesToSearch.push({
                  section: 'Break',
                  table: it.value,
                  rewardCount: 1
               });
            }
         });

         tablesToSearch.forEach(it =>
         {
            //Investigations can be 0
            if(0 !== it.rewardCount)
            {
               const materialData = monsterData[monsterName][rank][it.section][it.table].find(it => material === it.material);
               if(materialData) data.push({
                  tableCount: it.rewardCount,
                  itemCount: materialData.itemCount,
                  probability: materialData.probability
               });
            }
         });

         const questItemCount = Number.parseInt(document.getElementById('questItemCount').value);
         const questPercent = Number.parseInt(document.getElementById('questPercent').value);
         if(0 !== questItemCount && 0 !== questPercent)
         {
            data.push({tableCount: 3, itemCount: questItemCount, probability: questPercent / 100});
         }

         if(0 === data.length)
         {
            alert(`"${material}" can't be obtained from ${monsterName} at ${rank} with this form data.`);
            return;
         }

         crunchData(data, Number.parseInt(document.getElementById('huntCount').value));
      }

      //TODO: verify results via simulation (input small numbers)
      function crunchData(data, completeCount)
      {
         if(0 === data.length) alert('No data');  //unreachable through form
         const eachTable = [];
         for(let tableIndex = 0; tableIndex < data.length; ++tableIndex)
         {
            const thisTable = Combination.binomialDistribution(data[tableIndex].tableCount, data[tableIndex].probability);
            for(let outcomeIndex = 0; outcomeIndex < thisTable.length; ++outcomeIndex)
            {
               //convert number of times got reward to number of items
               thisTable[outcomeIndex].result *= data[tableIndex].itemCount;
            }
            eachTable.push(thisTable);
         }

         const everyHuntOutcome = calcEveryHuntOutcome(eachTable);
         let finalResults = everyHuntOutcome;
         if(1 !== completeCount)
         {
            const huntCartesianHolder = [];
            for(let completeIndex = 1; completeIndex <= completeCount; ++completeIndex)
            {
               huntCartesianHolder.push(everyHuntOutcome.copy());
            }
            finalResults = calcEveryHuntOutcome(huntCartesianHolder);
         }

         let out = '<b>Monster material</b> ';
         const aggregate = Statistics.calculateAggregates(finalResults);
         out += GenerateHtml.aggregates(aggregate);
         out += GenerateHtml.statistics(finalResults, '>='); //default col
         out = out.replace('<th>Roll</th>', '<th>Count</th>');  //easier to just edit than some new arg etc
         document.getElementById('graphResults').innerHTML = out;

         function calcEveryHuntOutcome(eachTable)
         {
            if(1 === eachTable.length) return eachTable[0];  //if there's only 1 table then this already is every outcome
            /*
             * eachTable[0].length ^ eachTable.length == huntCartesianProduct.length
             * magic number based on testing
             * max: Math.log(16777216) / Math.log(eachTable[0].length)
             * however 5 completeCount won't hit this and 5+ is unrealistic
             */
            const huntCartesianProduct = Combination.cartesianProduct(eachTable);
            const everyHuntOutcomeObj = {};
            for(let productIndex = 0; productIndex < huntCartesianProduct.length; ++productIndex)
            {
               let thisResult = 0;
               let thisProbability = 1;
               for(let resultIndex = 0; resultIndex < huntCartesianProduct[productIndex].length; ++resultIndex)
               {
                  thisResult += huntCartesianProduct[productIndex][resultIndex].result;
                  thisProbability *= huntCartesianProduct[productIndex][resultIndex].probability;
               }
               if(everyHuntOutcomeObj[thisResult] === undefined) everyHuntOutcomeObj[thisResult] = 0;
               everyHuntOutcomeObj[thisResult] += thisProbability;
            }
            const everyHuntOutcome = [];
            for(let resultProp in everyHuntOutcomeObj)
            {
               if(everyHuntOutcomeObj.hasOwnProperty(resultProp))
               {
                  everyHuntOutcome.push({result: Number.parseInt(resultProp), probability: everyHuntOutcomeObj[resultProp]});
               }
            }
            return everyHuntOutcome;
         }
      }
   </script>
</head>
<body>
<form action="javascript:readForm();" onchange="document.getElementById('graphResults').innerHTML = ''">
   <span id="promisePlaceholder">Waiting for data from
      <a href="https://mhworld.kiranico.com/">https://mhworld.kiranico.com/</a>...
   </span><br />
   <label>Monster to hunt:
      <input type="text" id="monster" style="visibility: hidden" value="Rathalos" onchange="makeMaterialAutoComplete()" />
   </label>
   <label>Material:
      <input type="text" id="material" style="visibility: hidden" value="Rathalos Scale" />
   </label><br />

   <label>Rank: <select id="huntRank">
      <option>Low Rank</option>
      <option>High Rank</option>
      <option>Master Rank</option>
   </select></label><br />

   <h2>Breaking parts</h2>
   <div id="breakingSection"></div>

   <h2><span title="Quest Rewards" class="hoverInfo">Quest</span></h2>
   <label>Material per reward slot <input type="number" min="1" value="1" max="5" id="questItemCount" /></label>
   <label>Chance <input type="number" min="0" max="100" value="0" id="questPercent" />%</label><br />

   <h2>Investigation reward slots</h2>
   <table>
      <tbody>
      <tr>
         <th><label for="bronzeReward" style="color: #993D00">Bronze</label></th>
         <th><label for="silverReward">Silver</label></th>
         <th><label for="goldReward" style="color: #E6E600">Gold</label></th>
         <th><label for="purpleReward" style="color: #8000FF">Purple</label></th>
      </tr>
      <tr>
         <td><input type="number" min="0" max="5" value="0" id="bronzeReward" /></td>
         <td><input type="number" min="0" max="5" value="0" id="silverReward" /></td>
         <td><input type="number" min="0" max="5" value="0" id="goldReward" /></td>
         <td><input type="number" min="0" max="5" value="0" id="purpleReward" /></td>
      </tr>
      </tbody>
   </table>
   <br />

   <label>Number of times you do will this hunt: <input type="number" min="1" value="1" max="5" id="huntCount" /></label><br />

   <input type="submit" value="Calculate" />
</form>
<br />
<div id="graphResults"></div>
<p>If you need a specific rare material in Monster Hunter World then input the stats of hunting a single monster and this will output the
   probability of each possible number of material you'll get.
   This programs calculates as much as possible and is pessimistic about the rest so that your actual odds should be better than reported.
   This scrapes data from <a href="https://mhworld.kiranico.com/">https://mhworld.kiranico.com/</a>.
   Text with red underline will show the name of the table from <a href="https://mhworld.kiranico.com/">kiranico</a> when you hover over it.
   First of all some terminology: a reward slot is a single square on the results page after a hunt. Each reward slot generally has 1
   material but it can have more than 1.</p>
<p><span title="Carves: Carves" class="hoverInfo">Carve</span> and <span title="Rewards: Capture" class="hoverInfo">Capture</span> are
   always identical tables the only difference is that you can always carve a dead monster 4 times, each of which puts in your box
   the equivalent of a reward slot (it won't be on the results page), but capturing will give 4 or 5 reward slots.
   However since I don't know the criteria/formula for when you would get 5 this calculator assumes you get 4 and
   thus they are completely identical which is why there's no input to indicate if the monster was captured.
   <span title="Rewards: Hunt" class="hoverInfo">Hunt</span> you get whether you kill or capture and is 4-8 reward slots however I once
   again don't know the criteria/formula so this assumes 4. An expedition would give 3-4 reward slots from the
   <span title="Rewards: Hunt" class="hoverInfo">Hunt</span> table but this calculator assumes you aren't doing an expedition.
   <span title="Carves: Carves" class="hoverInfo">Carve</span>/<span title="Rewards: Capture" class="hoverInfo">Capture</span> and
   <span title="Rewards: Hunt" class="hoverInfo">Hunt</span> are based on the large monster (I don't know how expeditions or multiple large
   monsters are calculated) and those tables are scraped from the large monster's page
   (and thus are covered by the name and material inputs).
   <span title="Quest Rewards" class="hoverInfo">Quest</span> is specific to the quest taken and this info can be found on
   <a href="https://mhworld.kiranico.com/quests">kiranico</a> as well.
   <span title="Quest Rewards" class="hoverInfo">Quest</span> will give 4-8 reward slots but the first
   <span title="Quest Rewards" class="hoverInfo">Quest</span> reward slot is always 100%
   (and thus doesn't need to be calculated) thus this calculator assumes 3.
   You may input the info for <span title="Quest Rewards" class="hoverInfo">Quest</span> above however it's unlikely to have the desired
   material.
   Investigations do in fact have <span title="Quest Rewards" class="hoverInfo">Quest</span>
   rewards which can be found <a href="https://game8.co/games/Monster-Hunter-World/archives/306257#hm_4">here</a>.
   You'll notice that (beside the 100%) they don't have percentages listed but this is the only place I could find the info.</p>
<p>After a hunt the "Quest completion rewards" will have the rewards from both <span title="Rewards: Hunt" class="hoverInfo">Hunt</span>
   and <span title="Quest Rewards" class="hoverInfo">Quest</span> the only way to tell them apart is that the
   <span title="Rewards: Hunt" class="hoverInfo">Hunt</span>
   rewards are first then the 100% <span title="Quest Rewards" class="hoverInfo">Quest</span> reward then the rest of the
   <span title="Quest Rewards" class="hoverInfo">Quest</span> rewards. The "Quest completion rewards" can hold a
   maximum of 20 reward slots (each might have multiple copies of the material) which is enough room for the max 16 slots for single
   monster hunts. The box below it "Bonus rewards" has 20 slots for materials from breaking monster parts then for Capture rewards (they
   will be labeled). After that are the Investigation slots (max of 5?) then the 20 Palico slots and 20 Tailraider slots
   (10 gathered and 10 stolen each).</p>
<p>Some monster breaks involve multiple body parts, such as having 2 wings. In that case each wing has it's own HP but both wings
   need to be broken to receive the reward slot for the break (for "Break Rathalos's wings") therefore you can only get 1 reward slot
   per break table per monster. This
   is why the input for breaking is a checkbox instead of asking how many times. There is a partial exception for
   <a href="https://mhworld.kiranico.com/monsters/aYaUV/nergigante">Nergigante</a> and
   <a href="https://mhworld.kiranico.com/monsters/oAnim/ruiner-nergigante">Ruiner Nergigante</a> who have "break horn" and "break horns"
   as separate tables for breaking 1 horn then both horns.
   <a href="https://mhworld.kiranico.com/monsters/oAnim/ruiner-nergigante">Ruiner Nergigante</a>
   also has separate tables for each front leg and each wing these cases are covered by having separate checkboxes
   (in this case 8 of them).</p>
<p><a href="https://mhworld.kiranico.com/">Kiranico</a> also has info on Tailraider Safari, Bandit Mantle, Plunderblade,
   Items Gathered by Palicoes, materials from Monster tracks, Dropped Material, Guiding lands, and basically everything you can think of.
   The Dropped Material table is
   what a monster may drop when they are toppled or have their body parts broken (the white items you have to pick up), which is not
   to be confused with the tables for "Break Rathalos's head" etc which are Bonus rewards for breaking monster parts at the end
   of a hunt. The calculator doesn't account for any of these except breaking and you should break as many parts are you can.</p>
<p><a href="https://mhworld.kiranico.com/monsters/EmVcV/zorah-magdaros">Zorah Magdaros</a> is excluded for now because the page's data
   is invalid: Carves master rank is missing, I don't know if it's ever possible to carve his corpse (so Carves: Carves should be N/A),
   Carves: Dropped Material is obviously impossible (you can break parts but not run to his feet to get a white material drop),
   Carves: Bandit Mantle is wrong since it lists non trade-in items, Carves: Plunderblade is impossible since your Palico won't help with
   the magma cores, Carves: Items Gathered by Palicoes is wrong since it lists a Bandit Mantle material, master rank of Rewards and
   Investigations are obviously wrong, Rewards: Capture Zorah Magdaros is probably impossible (ref:
   <a href="https://mhworld.kiranico.com/quests/nXmB6/one-for-the-history-books">★4 One for the History Books</a>),
   and Investigations doesn't apply to him at all (I think). Rewards: Break Zorah Magdaros's head, Rewards: Break Zorah Magdaros's chest,
   and Rewards: Hunt Zorah Magdaros might be valid but it breaks too many assumptions for this calculator to handle. In the future I might
   add special logic for handling Zorah Magdaros.</p>
<p><a href="https://mhworld.kiranico.com/monsters/aYaUV/nergigante">Nergigante</a> and
   <a href="https://mhworld.kiranico.com/monsters/oAnim/ruiner-nergigante">Ruiner Nergigante</a>
   have had some bad data ignored and thus can be used at HR and MR respectively (and no other rank). Every monster under Rewards of
   master rank has duplicate tables for Capture that seem to be guiding lands low, mid, high, and tempered: they are ignored.</p>
<p>Personal experience and rumors: I had all 20 "Quest completion rewards" filled in
   <a href="https://mhworld.kiranico.com/quests/naKbA/redefining-the-power-couple">★5 Redefining the "Power Couple"</a> since it's a 2
   monster quest it makes me think I was cheated out of the 4 possible remaining reward slots.
   Supposedly a Lucky Voucher will guarantee the max of 8 <span title="Quest Rewards" class="hoverInfo">Quest</span>
   rewards, I can't disprove that since
   I always get 8 when I have 0 faints and I usually don't faint. It is possible that the Lucky Voucher's description of
   "to add bonus rewards" is only talking about doubling the money (and thus doesn't affect what I call "reward slots" at all).
   Poogie does not affect the hunt at all (reward slots, material count, cash, or research points). Deal with it.
   Although if Poogie likes you (any amount) then you can use him to find treasure which are materials that could be sold.
   The armor skills Good Luck and Great Luck supposedly have a chance to increase the number of materials in a given reward slots but not
   the number of reward slots used and thus don't affect the chances of getting "at least 1" of the material desired. It would
   be very tedious to verify those skills since it would require doing a ton of hunts with the skill and comparing to the expected number
   of each material.</p>
<br /><br /><br /><br />
<script>
   'use strict';
   document.getElementById('monster').focus();
   makeMonsterAutoComplete();
</script>
</body>
</html>
